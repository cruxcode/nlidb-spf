[P-T2] [P-T2] Set: DYNSKIP -> -1.0
[P-T2] [P-T2] Adding entry: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: border :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: states :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c)
[P-T2] [P-T2] Adding entry: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the city of :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: neighbor :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: bordering :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: bordering :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: live :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: runs :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s)
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: number :- S/N : (lambda $0:<e,t> (count:<<e,t>,i> (lambda $1:e ($0 $1))))
[P-T2] [P-T2] Adding entry: border :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c)
[P-T2] [P-T2] Adding entry: live :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: cross_over :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0))
[P-T2] [P-T2] Adding entry: no :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
[P-T2] [P-T2] Adding entry: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))
[P-T2] [P-T2] Adding entry: smallest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c)
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0))
[P-T2] [P-T2] Adding entry: surround :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: surround :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: rivers :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: runs :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: runs :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c)
[P-T2] [P-T2] Adding entry: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c)
[P-T2] [P-T2] Adding entry: border :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: runs :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: rivers :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: neighbor :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: surrounding :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: surrounding :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: is :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2)))))
[P-T2] [P-T2] Adding entry: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c)
[P-T2] [P-T2] Adding entry: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))
[P-T2] [P-T2] Adding entry: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c)
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c)
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0))
[P-T2] [P-T2] Adding entry: cross_over :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c)
[P-T2] [P-T2] Adding entry: rivers :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: length :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the state of :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: longest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3)))))
[P-T2] [P-T2] Adding entry: population :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: which :- S/NP : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: borders :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: borders :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: states :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: borders :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s)
[P-T2] [P-T2] Adding entry: large :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c)
[P-T2] [P-T2] Adding entry: next_to :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: longest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: neighbor :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: larger :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c)
[P-T2] [P-T2] Adding entry: largest :- NP/N/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e ($0 $4))))))
[P-T2] [P-T2] Adding entry: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0))
[P-T2] [P-T2] Adding entry: neighbor :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c)
[P-T2] [P-T2] Adding entry: surround :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: borders :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: states :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c)
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: are :- S\NP/PP : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c)
[P-T2] [P-T2] Adding entry: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4))))))
[P-T2] [P-T2] Adding entry: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s)
[P-T2] [P-T2] Adding entry: are there :- S\NP : (lambda $0:e true:t)
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: cross-over :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: live :- S/PP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c)
[P-T2] [P-T2] Adding entry: tell me :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c)
[P-T2] [P-T2] Adding entry: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
[P-T2] [P-T2] Adding entry: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
[P-T2] [P-T2] Adding entry: what :- S/NP : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: is :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: states :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: have :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: bordering :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c)
[P-T2] [P-T2] Adding entry: cross_over :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s)
[P-T2] [P-T2] Adding entry: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: are :- N\N/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
[P-T2] [P-T2] Adding entry: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c)
[P-T2] [P-T2] Adding entry: population :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: run :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: run :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: how many :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))))
[P-T2] [P-T2] Adding entry: city :- N : (lambda $0:e (city:<c_pkey,t> $0))
[P-T2] [P-T2] Adding entry: rivers :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: live :- S/PP : (lambda $0:e (population:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c)
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c)
[P-T2] [P-T2] Adding entry: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c)
[P-T2] [P-T2] Adding entry: state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: surrounds :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: has :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: have :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: neighbors :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: which :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4))))))
[P-T2] [P-T2] Adding entry: the state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0))
[P-T2] [P-T2] Adding entry: state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: flow :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c)
[P-T2] [P-T2] Adding entry: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s)
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
[P-T2] [P-T2] Adding entry: does :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: the state of :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: length :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
[P-T2] [P-T2] Adding entry: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c)
[P-T2] [P-T2] Adding entry: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c)
[P-T2] [P-T2] Adding entry: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c)
[P-T2] [P-T2] Adding entry: have :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
[P-T2] [P-T2] Adding entry: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c)
[P-T2] [P-T2] Adding entry: the :- NP/NP : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: borders :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c)
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c)
[P-T2] [P-T2] Adding entry: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: can you :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: run :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s)
[P-T2] [P-T2] Adding entry: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s)
[P-T2] [P-T2] Adding entry: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c)
[P-T2] [P-T2] Adding entry: has :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: run :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: of :- NP/NP : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))
[P-T2] [P-T2] Adding entry: by :- N/N : (lambda $0:<e,e> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s)
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s)
[P-T2] [P-T2] Adding entry: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c)
[P-T2] [P-T2] Adding entry: cities :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the state of :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c)
[P-T2] [P-T2] Adding entry: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c)
[P-T2] [P-T2] Adding entry: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s)
[P-T2] [P-T2] Adding entry: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s)
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0))
[P-T2] [P-T2] Adding entry: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c)
[P-T2] [P-T2] Adding entry: neighbor :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c)
[P-T2] [P-T2] Adding entry: smallest :- NP/N/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e ($0 $4))))))
[P-T2] [P-T2] Adding entry: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c)
[P-T2] [P-T2] Adding entry: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: runs :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
[P-T2] [P-T2] Adding entry: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c)
[P-T2] [P-T2] Adding entry: not :- PP/PP : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0))
[P-T2] [P-T2] Adding entry: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))
[P-T2] [P-T2] Adding entry: city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s)
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0))
[P-T2] [P-T2] Adding entry: next_to :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s)
[P-T2] [P-T2] Adding entry: has :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: population :- S/PP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c)
[P-T2] [P-T2] Adding entry: live :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: border :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
[P-T2] [P-T2] Adding entry: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))
[P-T2] [P-T2] Adding entry: city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0))
[P-T2] [P-T2] Adding entry: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c)
[P-T2] [P-T2] Adding entry: area :- NP/PP : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: is :- S\NP/NP : (lambda $0:e (lambda $1:e (equals:<e,<e,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: next_to :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: run :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c)
[P-T2] [P-T2] Adding entry: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c)
[P-T2] [P-T2] Adding entry: are :- PP/PP : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: of :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: live :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c)
[P-T2] [P-T2] Adding entry: largest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
[P-T2] [P-T2] Adding entry: population :- S/PP : (lambda $0:e (population:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: biggest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: area :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c)
[P-T2] [P-T2] Adding entry: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c)
[P-T2] [P-T2] Adding entry: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c)
[P-T2] [P-T2] Adding entry: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: states :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: do not :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
[P-T2] [P-T2] Adding entry: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0))))
[P-T2] [P-T2] Adding entry: city :- N : (lambda $0:e (city:<c,t> $0))
[P-T2] [P-T2] Adding entry: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s)
[P-T2] [P-T2] Adding entry: next_to :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c)
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: states :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: population :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: sparsest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: the city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: next_to :- N : (lambda $0:e (next_to:<s_pkey,t> $0))
[P-T2] [P-T2] Adding entry: cities :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0))
[P-T2] [P-T2] Adding entry: the state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: length :- S/PP : (lambda $0:e (length:<r_pkey,i> $0))
[P-T2] [P-T2] Adding entry: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: with the :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: have :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c)
[P-T2] [P-T2] Adding entry: the city of :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: large :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: the state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c)
[P-T2] [P-T2] Adding entry: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c)
[P-T2] [P-T2] Adding entry: the city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: cities :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: states :- S/PP : (lambda $0:e (state:<s_pkey,s> $0))
[P-T2] [P-T2] Adding entry: flows :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4))))))
[P-T2] [P-T2] Adding entry: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0))
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: what :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
[P-T2] [P-T2] Adding entry: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c)
[P-T2] [P-T2] Adding entry: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: the state of :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: neighbors :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c)
[P-T2] [P-T2] Adding entry: the city of :- S/PP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c)
[P-T2] [P-T2] Adding entry: largest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3)))))
[P-T2] [P-T2] Adding entry: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: larger :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
[P-T2] [P-T2] Adding entry: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c)
[P-T2] [P-T2] Adding entry: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: the river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c)
[P-T2] [P-T2] Adding entry: city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: neighbors :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c)
[P-T2] [P-T2] Adding entry: the river :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0))
[P-T2] [P-T2] Adding entry: city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: surrounds :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: surrounds :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s)
[P-T2] [P-T2] Adding entry: that :- PP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4))))))
[P-T2] [P-T2] Adding entry: river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c)
[P-T2] [P-T2] Adding entry: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4))))))
[P-T2] [P-T2] Adding entry: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: in feet :- S\S : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c)
[P-T2] [P-T2] Adding entry: has :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
[P-T2] [P-T2] Adding entry: how many :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))))
[P-T2] [P-T2] Adding entry: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0))
[P-T2] [P-T2] Adding entry: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c)
[P-T2] [P-T2] Adding entry: highest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3)))))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s)
[P-T2] [P-T2] Adding entry: have :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0))
[P-T2] [P-T2] Adding entry: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c)
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: area :- S/PP : (lambda $0:e (area:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: flows :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: flows :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: cities :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c)
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0))
[P-T2] [P-T2] Adding entry: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: the city of :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: state :- N : (lambda $0:e (state:<s_pkey,t> $0))
[P-T2] [P-T2] Adding entry: the city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: neighbors :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: lowest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: least :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: which :- PP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the city of :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: has :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c)
[P-T2] [P-T2] Adding entry: flow :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: flows :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: live :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c)
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: please :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the state :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: please :- S\S : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c)
[P-T2] [P-T2] Adding entry: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s)
[P-T2] [P-T2] Adding entry: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c)
[P-T2] [P-T2] Adding entry: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: is :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: flows :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: city :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
[P-T2] [P-T2] Adding entry: not :- N/N : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
[P-T2] [P-T2] Adding entry: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s)
[P-T2] [P-T2] Adding entry: cities :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: show :- S/N : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: the river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s)
[P-T2] [P-T2] Adding entry: how many :- S/NP : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: flows :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s)
[P-T2] [P-T2] Adding entry: next_to :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0))
[P-T2] [P-T2] Adding entry: the state of :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c)
[P-T2] [P-T2] Adding entry: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: river :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: neighbors :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c)
[P-T2] [P-T2] Adding entry: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: highest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c)
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: states :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: live :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: the state :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c)
[P-T2] [P-T2] Adding entry: flow :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: flow :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s)
[P-T2] [P-T2] Adding entry: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c)
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0))
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0))
[P-T2] [P-T2] Adding entry: population :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: flow :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0))))
[P-T2] [P-T2] Adding entry: river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: next_to :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: with :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2)))))
[P-T2] [P-T2] Adding entry: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4))))))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: next_to :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c)
[P-T2] [P-T2] Adding entry: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: that :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: a :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: is :- S/S : (lambda $0:t $0)
[P-T2] [P-T2] Adding entry: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c)
[P-T2] [P-T2] Adding entry: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0))
[P-T2] [P-T2] Adding entry: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c)
[P-T2] [P-T2] Adding entry: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: area :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c)
[P-T2] [P-T2] Adding entry: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c)
[P-T2] [P-T2] Adding entry: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c)
[P-T2] [P-T2] Adding entry: river :- N : (lambda $0:e (river:<r,t> $0))
[P-T2] [P-T2] Adding entry: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
[P-T2] [P-T2] Adding entry: run :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c)
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: what :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
[P-T2] [P-T2] Adding entry: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c)
[P-T2] [P-T2] Adding entry: state :- N : (lambda $0:e (state:<s,t> $0))
[P-T2] [P-T2] Adding entry: is :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: population :- S/NP : (lambda $0:e (population:<lo,i> $0))
[P-T2] [P-T2] Adding entry: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c)
[P-T2] [P-T2] Adding entry: next_to :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2))))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: has :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
[P-T2] [P-T2] Adding entry: river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the :- NP/N : (lambda $0:<e,t> (the:<<e,t>,e> (lambda $1:e ($0 $1))))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: flow :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: surrounding :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s)
[P-T2] [P-T2] Adding entry: length :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0))
[P-T2] [P-T2] Adding entry: please :- S\S : (lambda $0:t $0)
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s)
[P-T2] [P-T2] Adding entry: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c)
[P-T2] [P-T2] Adding entry: in meters :- S\S : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: next_to :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: combined :- NP\N\N : (lambda $0:<e,t> (lambda $1:<e,e> (sum:<<e,t>,<<e,i>,i>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3)))))
[P-T2] [P-T2] Adding entry: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: does :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1)))
[P-T2] [P-T2] Adding entry: city :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
[P-T2] [P-T2] Adding entry: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))
[P-T2] [P-T2] Adding entry: rivers :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: area :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0))))
[P-T2] [P-T2] Adding entry: have :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
[P-T2] [P-T2] Adding entry: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: larger :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3)))))
[P-T2] [P-T2] Adding entry: higher :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
[P-T2] [P-T2] Adding entry: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2))))
[P-T2] [P-T2] Adding entry: total :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (sum:<<e,t>,<<e,i>,i>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c)
[P-T2] [P-T2] Adding entry: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c)
[P-T2] [P-T2] Adding entry: states :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0))
[P-T2] [P-T2] Adding entry: has :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: runs :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: neighbor :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: cross-over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: cross-over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: cross_over :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: cross_over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0))
[P-T2] [P-T2] Adding entry: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c)
[P-T2] [P-T2] Adding entry: how :- S/NP : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: most :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3)))))
[P-T2] [P-T2] Adding entry: is :- NP/NP : (lambda $0:e $0)
[P-T2] [P-T2] Adding entry: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: longer :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1))))
[P-T2] [P-T2] Adding entry: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c)
[P-T2] [P-T2] Adding entry: are :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2)))))
[P-T2] [P-T2] Adding entry: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))
[P-T2] [P-T2] Adding entry: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s)
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2)))))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1)))
[P-T2] [P-T2] Adding entry: have :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0))
[P-T2] [P-T2] Adding entry: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c)
[P-T2] [P-T2] Adding entry: length :- NP/PP : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
[P-T2] [P-T2] Adding entry: high :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
[P-T2] [P-T2] Adding entry: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: next_to :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
[P-T2] [P-T2] Adding entry: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s)
[P-T2] [P-T2] Adding entry: long :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
[P-T2] [P-T2] Adding entry: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c)
[P-T2] [P-T2] Adding entry: is :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0))
[P-T2] [P-T2] Adding entry: borders :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0)))
[P-T2] [P-T2] Adding entry: the state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
[P-T2] [P-T2] Adding entry: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4)))))))))
[P-T2] [P-T2] Adding entry: aurangabad :- NP : aurangabad:c
[P-T2] [P-T2] Adding entry: gurgaon :- NP : gurgaon:c
[P-T2] [P-T2] Adding entry: maharashtra :- NP : maharashtra:s
[P-T2] [P-T2] Adding entry: kanpur :- NP : kanpur:c
[P-T2] [P-T2] Adding entry: haryana :- NP : haryana:s
[P-T2] [P-T2] Adding entry: nagpur :- NP : nagpur:c
[P-T2] [P-T2] Adding entry: rishikesh :- NP : rishikesh:c
[P-T2] [P-T2] Adding entry: reewa :- NP : reewa:c
[P-T2] [P-T2] Adding entry: katni :- NP : katni:c
[P-T2] [P-T2] Adding entry: rajasthan :- NP : rajasthan:s
[P-T2] [P-T2] Adding entry: dehradun :- NP : dehradun:c
[P-T2] [P-T2] Adding entry: bhusawal :- NP : bhusawal:c
[P-T2] [P-T2] Adding entry: darbhanga :- NP : darbhanga:c
[P-T2] [P-T2] Adding entry: nainital :- NP : nainital:c
[P-T2] [P-T2] Adding entry: uttrakhand :- NP : uttrakhand:s
[P-T2] [P-T2] Adding entry: the state of haryana :- NP : haryana:s
[P-T2] [P-T2] Adding entry: madhya pradesh :- NP : madhya_pradesh:s
[P-T2] [P-T2] Adding entry: kurukshetra :- NP : kurukshetra:c
[P-T2] [P-T2] Adding entry: noida :- NP : noida:c
[P-T2] [P-T2] Adding entry: jalgaon :- NP : jalgaon:c
[P-T2] [P-T2] Adding entry: maharashtra state :- NP : maharashtra:s
[P-T2] [P-T2] Adding entry: mussoorie :- NP : mussoorie:c
[P-T2] [P-T2] Adding entry: the maharashtra :- NP : maharashtra:s
[P-T2] [P-T2] Adding entry: the aurangabad :- NP : aurangabad:c
[P-T2] [P-T2] Adding entry: bhopal :- NP : bhopal:c
[P-T2] [P-T2] Adding entry: kota :- NP : kota:c
[P-T2] [P-T2] Adding entry: khandwa :- NP : khandwa:c
[P-T2] [P-T2] Adding entry: deoghar :- NP : deoghar:c
[P-T2] [P-T2] Adding entry: jodhpur :- NP : jodhpur:c
[P-T2] [P-T2] Adding entry: uttar pradesh :- NP : uttar_pradesh:s
[P-T2] [P-T2] Adding entry: jharkhand :- NP : jharkhand:s
[P-T2] [P-T2] Adding entry: jaipur :- NP : jaipur:c
[P-T2] [P-T2] Adding entry: patna :- NP : patna:c
[P-T2] [P-T2] Adding entry: chandigarh :- NP : chandigarh:c
[P-T2] [P-T2] Adding entry: ranchi :- NP : ranchi:c
[P-T2] [P-T2] Adding entry: mumbai :- NP : mumbai:c
[P-T2] [P-T2] Adding entry: luckhnow :- NP : luckhnow:c
[P-T2] [P-T2] Adding entry: bihar :- NP : bihar:s
[P-T2] [P-T2] Init FACLEX#LEX: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#340#120=10.000(1.000),FACLEX#TMP#120=0.000(0.100),FACLEX#XEME#340=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#302#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#302=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1)))) -> {FACLEX#LEX#111#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#111=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#3#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#3=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c) -> {FACLEX#LEX#363#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#363=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#278#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#278=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#292#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#292=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#5#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#5=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city of :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#344#85=33.484(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#344=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbor :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#346#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#346=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bordering :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#194#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#194=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bordering :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#194#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#194=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#337#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#337=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#128#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#128=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#60#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#60=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: runs :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#361#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#361=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s) -> {FACLEX#LEX#216#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#216=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#347#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#347=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: number :- S/N : (lambda $0:<e,t> (count:<<e,t>,i> (lambda $1:e ($0 $1)))) -> {FACLEX#LEX#298#118=10.000(1.000),FACLEX#TMP#118=0.000(0.100),FACLEX#XEME#298=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#125#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#125=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c) -> {FACLEX#LEX#275#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#275=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#315#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#315=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1)))) -> {FACLEX#LEX#105#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#105=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#410#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#410=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#225#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#225=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross_over :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#159#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#159=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0)) -> {FACLEX#LEX#122#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#122=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: no :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#313#84=10.000(1.000),FACLEX#TMP#84=0.000(0.100),FACLEX#XEME#313=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#250#36=33.484(1.000),FACLEX#TMP#36=0.000(0.100),FACLEX#XEME#250=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#21#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#21=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c) -> {FACLEX#LEX#417#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#417=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0)) -> {FACLEX#LEX#135#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#135=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surround :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#348#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#348=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surround :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#348#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#348=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#284#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#284=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rivers :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#89#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#89=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: runs :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#99#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#99=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: runs :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#99#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#99=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#290#7=10.000(1.000),FACLEX#TMP#7=0.000(0.100),FACLEX#XEME#290=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c) -> {FACLEX#LEX#134#38=10.000(1.000),FACLEX#TMP#38=0.000(0.100),FACLEX#XEME#134=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#215#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#215=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c) -> {FACLEX#LEX#115#81=10.000(1.000),FACLEX#TMP#81=0.000(0.100),FACLEX#XEME#115=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#125#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#125=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: runs :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#157#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#157=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#29#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#29=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#178#10=10.000(1.000),FACLEX#TMP#10=0.000(0.100),FACLEX#XEME#178=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#309#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#309=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#368#95=10.000(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#368=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rivers :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#376#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#376=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbor :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#229#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#229=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#385#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#385=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surrounding :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#289#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#289=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surrounding :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#289#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#289=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2))))) -> {FACLEX#LEX#101#107=10.000(1.000),FACLEX#TMP#107=0.000(0.100),FACLEX#XEME#101=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#323#128=21.435(1.000),FACLEX#TMP#128=0.000(0.100),FACLEX#XEME#323=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2))))) -> {FACLEX#LEX#14#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#14=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#240#112=21.435(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#240=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c) -> {FACLEX#LEX#271#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#271=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#425#135=33.484(1.000),FACLEX#TMP#135=0.000(0.100),FACLEX#XEME#425=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#94#52=10.000(1.000),FACLEX#TMP#52=0.000(0.100),FACLEX#XEME#94=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#8#0=33.484(1.000),FACLEX#TMP#0=0.000(0.100),FACLEX#XEME#8=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#255#68=10.000(1.000),FACLEX#TMP#68=0.000(0.100),FACLEX#XEME#255=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c) -> {FACLEX#LEX#153#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#153=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0)) -> {FACLEX#LEX#167#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#167=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross_over :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#230#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#230=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c) -> {FACLEX#LEX#73#28=10.000(1.000),FACLEX#TMP#28=0.000(0.100),FACLEX#XEME#73=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rivers :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#89#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#89=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: length :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#279#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#279=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#84#3=33.484(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#84=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#218#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#218=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#338#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#338=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#94#19=10.000(1.000),FACLEX#TMP#19=0.000(0.100),FACLEX#XEME#94=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: which :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#38#93=10.000(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#38=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#243#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#243=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#243#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#243=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: borders :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#276#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#276=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: borders :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#276#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#276=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#196#130=21.435(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#196=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#277#30=10.000(1.000),FACLEX#TMP#30=0.000(0.100),FACLEX#XEME#277=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#3#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#3=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: borders :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#310#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#310=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s) -> {FACLEX#LEX#93#53=10.000(1.000),FACLEX#TMP#53=0.000(0.100),FACLEX#XEME#93=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: large :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#190#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#190=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c) -> {FACLEX#LEX#418#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#418=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#66#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#66=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#218#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#218=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbor :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#224#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#224=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0)) -> {FACLEX#LEX#65#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#65=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#177#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#177=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#321#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#321=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#168#26=10.000(1.000),FACLEX#TMP#26=0.000(0.100),FACLEX#XEME#168=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#397#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#397=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#241#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#241=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#241#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#241=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c) -> {FACLEX#LEX#23#12=10.000(1.000),FACLEX#TMP#12=0.000(0.100),FACLEX#XEME#23=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e ($0 $4)))))) -> {FACLEX#LEX#254#76=10.000(1.000),FACLEX#TMP#76=0.000(0.100),FACLEX#XEME#254=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#225#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#225=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0)) -> {FACLEX#LEX#6#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#6=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbor :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $1 $0))) -> {FACLEX#LEX#221#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#221=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c) -> {FACLEX#LEX#61#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#61=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surround :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#171#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#171=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#5#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#5=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#278#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#278=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: borders :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#17#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#17=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#173#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#173=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c) -> {FACLEX#LEX#47#70=10.000(1.000),FACLEX#TMP#70=0.000(0.100),FACLEX#XEME#47=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1)))) -> {FACLEX#LEX#212#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#212=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: are :- S\NP/PP : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#57#29=10.000(1.000),FACLEX#TMP#29=0.000(0.100),FACLEX#XEME#57=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c) -> {FACLEX#LEX#402#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#402=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#21#102=10.000(1.000),FACLEX#TMP#102=0.000(0.100),FACLEX#XEME#21=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#280#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#280=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s) -> {FACLEX#LEX#386#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#386=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: are there :- S\NP : (lambda $0:e true:t) -> {FACLEX#LEX#403#134=21.435(1.000),FACLEX#TMP#134=0.000(0.100),FACLEX#XEME#403=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#345#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#345=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross-over :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#35#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#35=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- S/PP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#19#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#19=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#273#117=10.000(1.000),FACLEX#TMP#117=0.000(0.100),FACLEX#XEME#273=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c) -> {FACLEX#LEX#76#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#76=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: tell me :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#30#78=21.435(1.000),FACLEX#TMP#78=0.000(0.100),FACLEX#XEME#30=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#228#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#228=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#362#132=21.435(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#362=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#280#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#280=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#238#9=21.435(1.000),FACLEX#TMP#9=0.000(0.100),FACLEX#XEME#238=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: what :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#204#93=10.000(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#204=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#101#51=10.000(1.000),FACLEX#TMP#51=0.000(0.100),FACLEX#XEME#101=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#166#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#166=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#55#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#55=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bordering :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#104#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#104=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c) -> {FACLEX#LEX#305#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#305=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross_over :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#230#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#230=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2))))) -> {FACLEX#LEX#257#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#257=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s) -> {FACLEX#LEX#398#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#398=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#387#130=10.000(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#387=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: are :- N\N/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))) -> {FACLEX#LEX#57#101=10.000(1.000),FACLEX#TMP#101=0.000(0.100),FACLEX#XEME#57=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c) -> {FACLEX#LEX#13#55=10.000(1.000),FACLEX#TMP#55=0.000(0.100),FACLEX#XEME#13=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#113#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#113=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: run :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#269#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#269=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: run :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#269#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#269=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: how many :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))) -> {FACLEX#LEX#209#129=21.435(1.000),FACLEX#TMP#129=0.000(0.100),FACLEX#XEME#209=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- N : (lambda $0:e (city:<c_pkey,t> $0)) -> {FACLEX#LEX#350#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#350=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rivers :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#319#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#319=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- S/PP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#128#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#128=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#388#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#388=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c) -> {FACLEX#LEX#349#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#349=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1))) -> {FACLEX#LEX#233#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#233=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#233#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#233=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#284#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#284=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1)))) -> {FACLEX#LEX#112#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#112=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c) -> {FACLEX#LEX#285#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#285=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c) -> {FACLEX#LEX#426#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#426=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#199#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#199=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1)))) -> {FACLEX#LEX#63#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#63=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#86#26=21.435(1.000),FACLEX#TMP#26=0.000(0.100),FACLEX#XEME#86=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surrounds :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#95#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#95=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#262#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#262=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#75#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#75=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#388#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#388=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#332#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#332=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#54#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#54=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbors :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#355#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#355=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: which :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#38#87=10.000(1.000),FACLEX#TMP#87=0.000(0.100),FACLEX#XEME#38=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#277#127=10.000(1.000),FACLEX#TMP#127=0.000(0.100),FACLEX#XEME#277=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#254#116=10.000(1.000),FACLEX#TMP#116=0.000(0.100),FACLEX#XEME#254=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#72#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#72=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0)) -> {FACLEX#LEX#201#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#201=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#82#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#82=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flow :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#371#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#371=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2))))) -> {FACLEX#LEX#242#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#242=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#140#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#140=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#140#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#140=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#56#4=21.435(1.000),FACLEX#TMP#4=0.000(0.100),FACLEX#XEME#56=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#364#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#364=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2))))) -> {FACLEX#LEX#301#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#301=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#45#2=21.435(1.000),FACLEX#TMP#2=0.000(0.100),FACLEX#XEME#45=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: does :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#91#51=10.000(1.000),FACLEX#TMP#51=0.000(0.100),FACLEX#XEME#91=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#365#5=33.484(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#365=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: length :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#85#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#85=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c) -> {FACLEX#LEX#109#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#109=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c) -> {FACLEX#LEX#41#34=10.000(1.000),FACLEX#TMP#34=0.000(0.100),FACLEX#XEME#41=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c) -> {FACLEX#LEX#353#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#353=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#28#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#28=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#258#64=10.000(1.000),FACLEX#TMP#64=0.000(0.100),FACLEX#XEME#258=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $0 $1))) -> {FACLEX#LEX#356#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#356=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $1 $0))) -> {FACLEX#LEX#356#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#356=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#236#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#236=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c) -> {FACLEX#LEX#119#6=10.000(1.000),FACLEX#TMP#6=0.000(0.100),FACLEX#XEME#119=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the :- NP/NP : (lambda $0:e $0) -> {FACLEX#LEX#121#99=10.000(1.000),FACLEX#TMP#99=0.000(0.100),FACLEX#XEME#121=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: borders :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#310#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#310=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0))) -> {FACLEX#LEX#256#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#256=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#404#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#404=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c) -> {FACLEX#LEX#235#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#235=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#254#97=10.000(1.000),FACLEX#TMP#97=0.000(0.100),FACLEX#XEME#254=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c) -> {FACLEX#LEX#286#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#286=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0))) -> {FACLEX#LEX#191#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#191=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: can you :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#100#78=21.435(1.000),FACLEX#TMP#78=0.000(0.100),FACLEX#XEME#100=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#31#125=10.000(1.000),FACLEX#TMP#125=0.000(0.100),FACLEX#XEME#31=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: run :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#10#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#10=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2))))) -> {FACLEX#LEX#274#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#274=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s) -> {FACLEX#LEX#287#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#287=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s) -> {FACLEX#LEX#377#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#377=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c) -> {FACLEX#LEX#318#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#318=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#51#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#51=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: run :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#378#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#378=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#175#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#175=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- NP/NP : (lambda $0:e $0) -> {FACLEX#LEX#152#99=10.000(1.000),FACLEX#TMP#99=0.000(0.100),FACLEX#XEME#152=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#333#126=33.484(1.000),FACLEX#TMP#126=0.000(0.100),FACLEX#XEME#333=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: by :- N/N : (lambda $0:<e,e> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#161#74=10.000(1.000),FACLEX#TMP#74=0.000(0.100),FACLEX#XEME#161=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#116#112=10.000(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#116=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#154#66=10.000(1.000),FACLEX#TMP#66=0.000(0.100),FACLEX#XEME#154=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1)))) -> {FACLEX#LEX#29#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#29=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s) -> {FACLEX#LEX#239#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#239=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#44#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#44=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c) -> {FACLEX#LEX#351#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#351=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cities :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#182#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#182=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#84#8=33.484(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#84=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#419#130=10.000(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#419=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#385#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#385=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#227#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#227=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c) -> {FACLEX#LEX#83#50=10.000(1.000),FACLEX#TMP#50=0.000(0.100),FACLEX#XEME#83=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c) -> {FACLEX#LEX#217#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#217=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s) -> {FACLEX#LEX#90#43=10.000(1.000),FACLEX#TMP#43=0.000(0.100),FACLEX#XEME#90=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#312#54=45.948(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#312=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0)) -> {FACLEX#LEX#88#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#88=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#307#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#307=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#307#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#307=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#136#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#136=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#420#54=33.484(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#420=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbor :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#229#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#229=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#172#120=21.435(1.000),FACLEX#TMP#120=0.000(0.100),FACLEX#XEME#172=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#405#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#405=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e ($0 $4)))))) -> {FACLEX#LEX#21#76=10.000(1.000),FACLEX#TMP#76=0.000(0.100),FACLEX#XEME#21=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c) -> {FACLEX#LEX#352#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#352=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#36#26=21.435(1.000),FACLEX#TMP#26=0.000(0.100),FACLEX#XEME#36=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1)))) -> {FACLEX#LEX#88#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#88=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: runs :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#157#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#157=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1)))) -> {FACLEX#LEX#143#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#143=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#45#20=21.435(1.000),FACLEX#TMP#20=0.000(0.100),FACLEX#XEME#45=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c) -> {FACLEX#LEX#379#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#379=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: not :- PP/PP : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#192#123=10.000(1.000),FACLEX#TMP#123=0.000(0.100),FACLEX#XEME#192=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0)) -> {FACLEX#LEX#143#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#143=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#427#136=33.484(1.000),FACLEX#TMP#136=0.000(0.100),FACLEX#XEME#427=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#137#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#137=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#294#90=10.000(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#294=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#24#66=45.948(1.000),FACLEX#TMP#66=0.000(0.100),FACLEX#XEME#24=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#178#41=10.000(1.000),FACLEX#TMP#41=0.000(0.100),FACLEX#XEME#178=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#149#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#149=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#15#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#15=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1)))) -> {FACLEX#LEX#138#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#138=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#199#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#199=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#64#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#64=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#406#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#406=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#283#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#283=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#283#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#283=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#48#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#48=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1)))) -> {FACLEX#LEX#186#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#186=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s) -> {FACLEX#LEX#326#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#326=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#151#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#151=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#368#130=10.000(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#368=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#268#90=21.435(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#268=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- S/PP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#27#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#27=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c) -> {FACLEX#LEX#314#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#314=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#315#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#315=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0))) -> {FACLEX#LEX#107#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#107=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#360#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#360=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#288#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#288=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: border :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#302#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#302=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#227#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#227=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#251#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#251=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#162#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#162=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#145#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#145=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#267#131=21.435(1.000),FACLEX#TMP#131=0.000(0.100),FACLEX#XEME#267=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#244#108=33.484(1.000),FACLEX#TMP#108=0.000(0.100),FACLEX#XEME#244=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#331#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#331=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0)) -> {FACLEX#LEX#212#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#212=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#247#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#247=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: area :- NP/PP : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#336#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#336=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#82#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#82=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- S\NP/NP : (lambda $0:e (lambda $1:e (equals:<e,<e,t>> $1 $0))) -> {FACLEX#LEX#80#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#80=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#291#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#291=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: run :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#378#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#378=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#354#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#354=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#77#1=10.000(1.000),FACLEX#TMP#1=0.000(0.100),FACLEX#XEME#77=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#317#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#317=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c) -> {FACLEX#LEX#103#31=10.000(1.000),FACLEX#TMP#31=0.000(0.100),FACLEX#XEME#103=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#354#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#354=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1)))) -> {FACLEX#LEX#6#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#6=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c) -> {FACLEX#LEX#130#46=10.000(1.000),FACLEX#TMP#46=0.000(0.100),FACLEX#XEME#130=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: are :- PP/PP : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#57#82=10.000(1.000),FACLEX#TMP#82=0.000(0.100),FACLEX#XEME#57=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#152#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#152=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#19#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#19=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#97#90=10.000(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#97=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c) -> {FACLEX#LEX#1#13=10.000(1.000),FACLEX#TMP#13=0.000(0.100),FACLEX#XEME#1=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#254#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#254=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#421#105=21.435(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#421=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- S/PP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#113#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#113=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: biggest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#272#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#272=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: area :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#336#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#336=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1))) -> {FACLEX#LEX#297#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#297=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#297#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#297=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c) -> {FACLEX#LEX#156#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#156=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c) -> {FACLEX#LEX#380#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#380=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c) -> {FACLEX#LEX#422#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#422=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#389#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#389=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#173#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#173=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#131#7=10.000(1.000),FACLEX#TMP#7=0.000(0.100),FACLEX#XEME#131=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: do not :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#158#84=21.435(1.000),FACLEX#TMP#84=0.000(0.100),FACLEX#XEME#158=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0)))) -> {FACLEX#LEX#248#110=10.000(1.000),FACLEX#TMP#110=0.000(0.100),FACLEX#XEME#248=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- N : (lambda $0:e (city:<c,t> $0)) -> {FACLEX#LEX#390#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#390=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s) -> {FACLEX#LEX#92#23=21.435(1.000),FACLEX#TMP#23=0.000(0.100),FACLEX#XEME#92=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#291#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#291=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#120#17=10.000(1.000),FACLEX#TMP#17=0.000(0.100),FACLEX#XEME#120=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c) -> {FACLEX#LEX#118#77=10.000(1.000),FACLEX#TMP#77=0.000(0.100),FACLEX#XEME#118=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#296#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#296=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#166#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#166=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#195#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#195=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: sparsest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#203#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#203=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#42#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#42=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2))))) -> {FACLEX#LEX#7#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#7=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- N : (lambda $0:e (next_to:<s_pkey,t> $0)) -> {FACLEX#LEX#249#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#249=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cities :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#160#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#160=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0)) -> {FACLEX#LEX#63#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#63=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#72#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#72=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: length :- S/PP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#85#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#85=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#281#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#281=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: with the :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#11#87=21.435(1.000),FACLEX#TMP#87=0.000(0.100),FACLEX#XEME#11=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#299#128=10.000(1.000),FACLEX#TMP#128=0.000(0.100),FACLEX#XEME#299=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#213#51=10.000(1.000),FACLEX#TMP#51=0.000(0.100),FACLEX#XEME#213=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#246#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#246=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c) -> {FACLEX#LEX#142#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#142=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city of :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#259#5=33.484(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#259=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: large :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#40#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#40=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#68#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#68=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#137#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#137=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1)))) -> {FACLEX#LEX#65#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#65=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c) -> {FACLEX#LEX#369#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#369=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c) -> {FACLEX#LEX#58#45=10.000(1.000),FACLEX#TMP#45=0.000(0.100),FACLEX#XEME#58=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#251#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#251=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cities :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#160#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#160=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#31#133=10.000(1.000),FACLEX#TMP#133=0.000(0.100),FACLEX#XEME#31=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S/PP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#34#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#34=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flows :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#214#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#214=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#240#90=21.435(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#240=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#120#44=10.000(1.000),FACLEX#TMP#44=0.000(0.100),FACLEX#XEME#120=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#387#95=10.000(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#387=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0)) -> {FACLEX#LEX#105#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#105=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2)))) -> {FACLEX#LEX#98#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#98=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: what :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))) -> {FACLEX#LEX#204#11=10.000(1.000),FACLEX#TMP#11=0.000(0.100),FACLEX#XEME#204=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c) -> {FACLEX#LEX#366#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#366=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#407#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#407=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#200#85=33.484(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#200=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#121#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#121=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbors :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#146#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#146=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#334#117=10.000(1.000),FACLEX#TMP#117=0.000(0.100),FACLEX#XEME#334=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c) -> {FACLEX#LEX#293#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#293=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city of :- S/PP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#74#3=33.484(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#74=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#48#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#48=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#334#114=10.000(1.000),FACLEX#TMP#114=0.000(0.100),FACLEX#XEME#334=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#126#0=10.000(1.000),FACLEX#TMP#0=0.000(0.100),FACLEX#XEME#126=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#254#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#254=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#394#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#394=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#53#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#53=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#32#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#32=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#325#130=21.435(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#325=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2)))) -> {FACLEX#LEX#46#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#46=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0))))) -> {FACLEX#LEX#255#21=10.000(1.000),FACLEX#TMP#21=0.000(0.100),FACLEX#XEME#255=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c) -> {FACLEX#LEX#339#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#339=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#253#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#253=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#411#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#411=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#340#119=10.000(1.000),FACLEX#TMP#119=0.000(0.100),FACLEX#XEME#340=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#53#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#53=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c) -> {FACLEX#LEX#408#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#408=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#392#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#392=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbors :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#146#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#146=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#391#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#391=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c) -> {FACLEX#LEX#370#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#370=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the river :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#223#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#223=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0)) -> {FACLEX#LEX#111#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#111=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1)))) -> {FACLEX#LEX#25#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#25=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0)) -> {FACLEX#LEX#139#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#139=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#392#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#392=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surrounds :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#329#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#329=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surrounds :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#329#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#329=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s) -> {FACLEX#LEX#174#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#174=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: that :- PP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#245#100=10.000(1.000),FACLEX#TMP#100=0.000(0.100),FACLEX#XEME#245=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#345#65=10.000(1.000),FACLEX#TMP#65=0.000(0.100),FACLEX#XEME#345=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#381#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#381=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c) -> {FACLEX#LEX#18#48=10.000(1.000),FACLEX#TMP#48=0.000(0.100),FACLEX#XEME#18=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#360#122=10.000(1.000),FACLEX#TMP#122=0.000(0.100),FACLEX#XEME#360=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#295#120=10.000(1.000),FACLEX#TMP#120=0.000(0.100),FACLEX#XEME#295=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in feet :- S\S : (lambda $0:e $0) -> {FACLEX#LEX#184#109=21.435(1.000),FACLEX#TMP#109=0.000(0.100),FACLEX#XEME#184=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#26#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#26=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c) -> {FACLEX#LEX#413#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#413=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#148#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#148=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: how many :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))) -> {FACLEX#LEX#209#121=21.435(1.000),FACLEX#TMP#121=0.000(0.100),FACLEX#XEME#209=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#316#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#316=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0)) -> {FACLEX#LEX#110#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#110=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#141#4=10.000(1.000),FACLEX#TMP#4=0.000(0.100),FACLEX#XEME#141=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#124#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#124=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1)))) -> {FACLEX#LEX#110#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#110=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#382#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#382=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s) -> {FACLEX#LEX#133#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#133=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#150#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#150=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#49#17=10.000(1.000),FACLEX#TMP#17=0.000(0.100),FACLEX#XEME#49=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#393#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#393=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0)) -> {FACLEX#LEX#112#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#112=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c) -> {FACLEX#LEX#22#40=10.000(1.000),FACLEX#TMP#40=0.000(0.100),FACLEX#XEME#22=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2)))) -> {FACLEX#LEX#254#92=10.000(1.000),FACLEX#TMP#92=0.000(0.100),FACLEX#XEME#254=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: area :- S/PP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#4#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#4=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flows :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#220#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#220=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flows :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#220#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#220=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cities :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#182#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#182=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#147#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#147=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c) -> {FACLEX#LEX#400#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#400=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0)) -> {FACLEX#LEX#234#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#234=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#97#112=10.000(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#97=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#116#90=10.000(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#116=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city of :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#74#8=33.484(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#74=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- N : (lambda $0:e (state:<s_pkey,t> $0)) -> {FACLEX#LEX#185#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#185=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#42#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#42=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbors :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#409#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#409=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#32#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#32=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#323#96=21.435(1.000),FACLEX#TMP#96=0.000(0.100),FACLEX#XEME#323=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: lowest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#258#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#258=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: least :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#294#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#294=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#394#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#394=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#78#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#78=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#78#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#78=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: which :- PP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#38#100=10.000(1.000),FACLEX#TMP#100=0.000(0.100),FACLEX#XEME#38=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#393#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#393=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the city of :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#259#103=33.484(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#259=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#187#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#187=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#187#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#187=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c) -> {FACLEX#LEX#12#57=10.000(1.000),FACLEX#TMP#57=0.000(0.100),FACLEX#XEME#12=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flow :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#371#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#371=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flows :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#320#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#320=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#263#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#263=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#428#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#428=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c) -> {FACLEX#LEX#81#25=10.000(1.000),FACLEX#TMP#25=0.000(0.100),FACLEX#XEME#81=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#255#61=10.000(1.000),FACLEX#TMP#61=0.000(0.100),FACLEX#XEME#255=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: please :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#188#78=10.000(1.000),FACLEX#TMP#78=0.000(0.100),FACLEX#XEME#188=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#395#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#395=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#106#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#106=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#321#97=10.000(1.000),FACLEX#TMP#97=0.000(0.100),FACLEX#XEME#321=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: please :- S\S : (lambda $0:e $0) -> {FACLEX#LEX#188#109=10.000(1.000),FACLEX#TMP#109=0.000(0.100),FACLEX#XEME#188=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#423#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#423=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s) -> {FACLEX#LEX#414#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#414=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c) -> {FACLEX#LEX#169#33=10.000(1.000),FACLEX#TMP#33=0.000(0.100),FACLEX#XEME#169=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2)))) -> {FACLEX#LEX#218#89=10.000(1.000),FACLEX#TMP#89=0.000(0.100),FACLEX#XEME#218=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2)))) -> {FACLEX#LEX#59#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#59=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#101#104=10.000(1.000),FACLEX#TMP#104=0.000(0.100),FACLEX#XEME#101=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flows :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#214#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#214=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#395#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#395=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#37#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#37=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: not :- N/N : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#192#94=10.000(1.000),FACLEX#TMP#94=0.000(0.100),FACLEX#XEME#192=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s) -> {FACLEX#LEX#62#59=21.435(1.000),FACLEX#TMP#59=0.000(0.100),FACLEX#XEME#62=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cities :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0))) -> {FACLEX#LEX#237#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#237=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2)))) -> {FACLEX#LEX#372#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#372=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: show :- S/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#193#67=10.000(1.000),FACLEX#TMP#67=0.000(0.100),FACLEX#XEME#193=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1)))) -> {FACLEX#LEX#201#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#201=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#391#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#391=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#260#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#260=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: how many :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#71#93=21.435(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#71=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flows :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#320#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#320=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1)))) -> {FACLEX#LEX#79#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#79=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#373#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#373=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#330#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#330=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#123#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#123=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#365#103=33.484(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#365=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c) -> {FACLEX#LEX#0#35=10.000(1.000),FACLEX#TMP#35=0.000(0.100),FACLEX#XEME#0=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#196#95=21.435(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#196=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1)))) -> {FACLEX#LEX#43#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#43=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2))))) -> {FACLEX#LEX#117#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#117=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: river :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#132#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#132=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbors :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#409#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#409=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c) -> {FACLEX#LEX#211#18=10.000(1.000),FACLEX#TMP#18=0.000(0.100),FACLEX#XEME#211=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#170#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#170=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#124#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#124=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c) -> {FACLEX#LEX#322#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#322=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#252#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#252=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#67#14=10.000(1.000),FACLEX#TMP#14=0.000(0.100),FACLEX#XEME#67=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#207#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#207=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#20#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#20=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#263#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#263=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#198#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#198=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#412#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#412=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#106#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#106=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#341#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#341=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flow :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#210#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#210=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flow :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#210#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#210=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1)))) -> {FACLEX#LEX#123#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#123=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#149#19=10.000(1.000),FACLEX#TMP#19=0.000(0.100),FACLEX#XEME#149=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s) -> {FACLEX#LEX#176#24=10.000(1.000),FACLEX#TMP#24=0.000(0.100),FACLEX#XEME#176=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c) -> {FACLEX#LEX#374#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#374=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1)))) -> {FACLEX#LEX#33#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#33=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#401#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#401=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#43#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#43=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0)) -> {FACLEX#LEX#33#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#33=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#27#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#27=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#164#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#164=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#164#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#164=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flow :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#144#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#144=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0)))) -> {FACLEX#LEX#270#115=10.000(1.000),FACLEX#TMP#115=0.000(0.100),FACLEX#XEME#270=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#15#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#15=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#129#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#129=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: with :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2))))) -> {FACLEX#LEX#231#107=10.000(1.000),FACLEX#TMP#107=0.000(0.100),FACLEX#XEME#231=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#60#15=10.000(1.000),FACLEX#TMP#15=0.000(0.100),FACLEX#XEME#60=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1)))) -> {FACLEX#LEX#135#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#135=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#64#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#64=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c) -> {FACLEX#LEX#265#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#265=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#311#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#311=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#124#64=10.000(1.000),FACLEX#TMP#64=0.000(0.100),FACLEX#XEME#124=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#226#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#226=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: that :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#245#87=10.000(1.000),FACLEX#TMP#87=0.000(0.100),FACLEX#XEME#245=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: a :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#208#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#208=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2))))) -> {FACLEX#LEX#222#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#222=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- S/S : (lambda $0:t $0) -> {FACLEX#LEX#101#37=10.000(1.000),FACLEX#TMP#37=0.000(0.100),FACLEX#XEME#101=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c) -> {FACLEX#LEX#342#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#342=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#415#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#415=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#136#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#136=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c) -> {FACLEX#LEX#424#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#424=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#266#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#266=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: area :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#4#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#4=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c) -> {FACLEX#LEX#2#63=10.000(1.000),FACLEX#TMP#63=0.000(0.100),FACLEX#XEME#2=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c) -> {FACLEX#LEX#383#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#383=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c) -> {FACLEX#LEX#399#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#399=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: river :- N : (lambda $0:e (river:<r,t> $0)) -> {FACLEX#LEX#343#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#343=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#411#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#411=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#267#113=21.435(1.000),FACLEX#TMP#113=0.000(0.100),FACLEX#XEME#267=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: run :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#10#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#10=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#268#112=21.435(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#268=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c) -> {FACLEX#LEX#127#16=10.000(1.000),FACLEX#TMP#16=0.000(0.100),FACLEX#XEME#127=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#181#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#181=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#77#56=10.000(1.000),FACLEX#TMP#56=0.000(0.100),FACLEX#XEME#77=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: what :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))) -> {FACLEX#LEX#204#62=10.000(1.000),FACLEX#TMP#62=0.000(0.100),FACLEX#XEME#204=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c) -> {FACLEX#LEX#357#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#357=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- N : (lambda $0:e (state:<s,t> $0)) -> {FACLEX#LEX#324#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#324=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#101#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#101=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- S/NP : (lambda $0:e (population:<lo,i> $0)) -> {FACLEX#LEX#102#49=10.000(1.000),FACLEX#TMP#49=0.000(0.100),FACLEX#XEME#102=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#21#71=10.000(1.000),FACLEX#TMP#71=0.000(0.100),FACLEX#XEME#21=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c) -> {FACLEX#LEX#303#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#303=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#66#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#66=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#124#97=10.000(1.000),FACLEX#TMP#97=0.000(0.100),FACLEX#XEME#124=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#206#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#206=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#206#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#206=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#39#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#39=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#381#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#381=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#299#96=10.000(1.000),FACLEX#TMP#96=0.000(0.100),FACLEX#XEME#299=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#26#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#26=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#415#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#415=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the :- NP/N : (lambda $0:<e,t> (the:<<e,t>,e> (lambda $1:e ($0 $1)))) -> {FACLEX#LEX#121#98=10.000(1.000),FACLEX#TMP#98=0.000(0.100),FACLEX#XEME#121=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1)))) -> {FACLEX#LEX#234#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#234=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: flow :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#144#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#144=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: surrounding :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#50#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#50=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#382#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#382=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#396#69=45.948(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#396=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: length :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#327#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#327=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0)) -> {FACLEX#LEX#25#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#25=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: please :- S\S : (lambda $0:t $0) -> {FACLEX#LEX#188#106=10.000(1.000),FACLEX#TMP#106=0.000(0.100),FACLEX#XEME#188=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#96#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#96=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s) -> {FACLEX#LEX#232#47=10.000(1.000),FACLEX#TMP#47=0.000(0.100),FACLEX#XEME#232=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1)))) -> {FACLEX#LEX#139#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#139=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#419#95=10.000(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#419=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c) -> {FACLEX#LEX#189#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#189=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: in meters :- S\S : (lambda $0:e $0) -> {FACLEX#LEX#202#109=21.435(1.000),FACLEX#TMP#109=0.000(0.100),FACLEX#XEME#202=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#163#7=10.000(1.000),FACLEX#TMP#7=0.000(0.100),FACLEX#XEME#163=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#108#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#108=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1)))) -> {FACLEX#LEX#122#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#122=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#358#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#358=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: combined :- NP\N\N : (lambda $0:<e,t> (lambda $1:<e,e> (sum:<<e,t>,<<e,i>,i>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#306#80=10.000(1.000),FACLEX#TMP#80=0.000(0.100),FACLEX#XEME#306=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#295#119=10.000(1.000),FACLEX#TMP#119=0.000(0.100),FACLEX#XEME#295=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#401#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#401=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: does :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#91#104=10.000(1.000),FACLEX#TMP#104=0.000(0.100),FACLEX#XEME#91=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#37#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#37=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#261#79=33.484(1.000),FACLEX#TMP#79=0.000(0.100),FACLEX#XEME#261=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rivers :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#376#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#376=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: area :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#69#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#69=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0)))) -> {FACLEX#LEX#16#58=10.000(1.000),FACLEX#TMP#58=0.000(0.100),FACLEX#XEME#16=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#155#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#155=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#325#95=21.435(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#325=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#321#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#321=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0))))) -> {FACLEX#LEX#335#21=10.000(1.000),FACLEX#TMP#21=0.000(0.100),FACLEX#XEME#335=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#254#71=10.000(1.000),FACLEX#TMP#71=0.000(0.100),FACLEX#XEME#254=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: total :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (sum:<<e,t>,<<e,i>,i>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#183#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#183=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#367#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#367=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#282#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#282=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2))))) -> {FACLEX#LEX#70#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#70=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c) -> {FACLEX#LEX#384#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#384=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#359#72=21.435(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#359=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#34#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#34=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: has :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#304#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#304=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: runs :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#361#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#361=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: neighbor :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#346#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#346=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross-over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#308#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#308=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross-over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#308#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#308=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross_over :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#159#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#159=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#273#114=10.000(1.000),FACLEX#TMP#114=0.000(0.100),FACLEX#XEME#273=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#335#61=10.000(1.000),FACLEX#TMP#61=0.000(0.100),FACLEX#XEME#335=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: cross_over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#205#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#205=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0)) -> {FACLEX#LEX#186#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#186=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c) -> {FACLEX#LEX#328#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#328=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: how :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#165#93=10.000(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#165=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: most :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#116#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#116=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- NP/NP : (lambda $0:e $0) -> {FACLEX#LEX#101#99=10.000(1.000),FACLEX#TMP#99=0.000(0.100),FACLEX#XEME#101=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#172#119=21.435(1.000),FACLEX#TMP#119=0.000(0.100),FACLEX#XEME#172=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: longer :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0))))) -> {FACLEX#LEX#67#21=10.000(1.000),FACLEX#TMP#21=0.000(0.100),FACLEX#XEME#67=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1)))) -> {FACLEX#LEX#167#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#167=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c) -> {FACLEX#LEX#114#39=10.000(1.000),FACLEX#TMP#39=0.000(0.100),FACLEX#XEME#114=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: are :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2))))) -> {FACLEX#LEX#57#107=10.000(1.000),FACLEX#TMP#107=0.000(0.100),FACLEX#XEME#57=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#197#88=33.484(1.000),FACLEX#TMP#88=0.000(0.100),FACLEX#XEME#197=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s) -> {FACLEX#LEX#300#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#300=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#87#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#87=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#9#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#9=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: have :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#9#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#9=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0)) -> {FACLEX#LEX#79#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#79=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#264#72=33.484(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#264=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: length :- NP/PP : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#327#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#327=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#149#52=10.000(1.000),FACLEX#TMP#52=0.000(0.100),FACLEX#XEME#149=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: high :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#52#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#52=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#180#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#180=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: next_to :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#358#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#358=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s) -> {FACLEX#LEX#416#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#416=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: long :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#219#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#219=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c) -> {FACLEX#LEX#375#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#375=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: is :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0)) -> {FACLEX#LEX#138#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#138=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: borders :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#17#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#17=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0))) -> {FACLEX#LEX#179#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#179=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#68#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#68=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#294#112=10.000(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#294=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: aurangabad :- NP : aurangabad:c -> {FACLEX#LEX#341#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#341=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: gurgaon :- NP : gurgaon:c -> {FACLEX#LEX#153#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#153=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra :- NP : maharashtra:s -> {FACLEX#LEX#147#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#147=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kanpur :- NP : kanpur:c -> {FACLEX#LEX#374#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#374=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: haryana :- NP : haryana:s -> {FACLEX#LEX#260#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#260=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nagpur :- NP : nagpur:c -> {FACLEX#LEX#271#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#271=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rishikesh :- NP : rishikesh:c -> {FACLEX#LEX#142#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#142=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: reewa :- NP : reewa:c -> {FACLEX#LEX#286#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#286=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: katni :- NP : katni:c -> {FACLEX#LEX#303#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#303=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: rajasthan :- NP : rajasthan:s -> {FACLEX#LEX#398#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#398=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: dehradun :- NP : dehradun:c -> {FACLEX#LEX#349#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#349=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhusawal :- NP : bhusawal:c -> {FACLEX#LEX#408#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#408=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: darbhanga :- NP : darbhanga:c -> {FACLEX#LEX#328#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#328=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: nainital :- NP : nainital:c -> {FACLEX#LEX#402#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#402=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttrakhand :- NP : uttrakhand:s -> {FACLEX#LEX#300#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#300=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the state of haryana :- NP : haryana:s -> {FACLEX#LEX#396#137=45.948(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#396=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: madhya pradesh :- NP : madhya_pradesh:s -> {FACLEX#LEX#133#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#133=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kurukshetra :- NP : kurukshetra:c -> {FACLEX#LEX#399#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#399=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: noida :- NP : noida:c -> {FACLEX#LEX#339#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#339=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jalgaon :- NP : jalgaon:c -> {FACLEX#LEX#353#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#353=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: maharashtra state :- NP : maharashtra:s -> {FACLEX#LEX#332#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#332=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mussoorie :- NP : mussoorie:c -> {FACLEX#LEX#379#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#379=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the maharashtra :- NP : maharashtra:s -> {FACLEX#LEX#253#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#253=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: the aurangabad :- NP : aurangabad:c -> {FACLEX#LEX#359#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#359=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bhopal :- NP : bhopal:c -> {FACLEX#LEX#318#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#318=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: kota :- NP : kota:c -> {FACLEX#LEX#305#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#305=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: khandwa :- NP : khandwa:c -> {FACLEX#LEX#275#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#275=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: deoghar :- NP : deoghar:c -> {FACLEX#LEX#235#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#235=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jodhpur :- NP : jodhpur:c -> {FACLEX#LEX#109#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#109=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: uttar pradesh :- NP : uttar_pradesh:s -> {FACLEX#LEX#239#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#239=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jharkhand :- NP : jharkhand:s -> {FACLEX#LEX#216#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#216=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: jaipur :- NP : jaipur:c -> {FACLEX#LEX#369#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#369=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: patna :- NP : patna:c -> {FACLEX#LEX#189#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#189=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: chandigarh :- NP : chandigarh:c -> {FACLEX#LEX#357#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#357=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: ranchi :- NP : ranchi:c -> {FACLEX#LEX#217#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#217=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: mumbai :- NP : mumbai:c -> {FACLEX#LEX#247#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#247=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: luckhnow :- NP : luckhnow:c -> {FACLEX#LEX#363#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#363=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#LEX: bihar :- NP : bihar:s -> {FACLEX#LEX#326#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#326=0.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#340#120=10.000(1.000),FACLEX#TMP#120=0.000(0.100),FACLEX#XEME#340=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#302#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#302=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1)))) -> {FACLEX#LEX#111#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#111=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#3#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#3=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c) -> {FACLEX#LEX#363#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#363=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#278#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#278=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#292#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#292=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#5#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#5=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city of :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#344#85=33.484(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#344=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbor :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#346#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#346=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bordering :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#194#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#194=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bordering :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#194#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#194=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#337#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#337=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#128#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#128=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#60#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#60=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: runs :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#361#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#361=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s) -> {FACLEX#LEX#216#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#216=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#347#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#347=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: number :- S/N : (lambda $0:<e,t> (count:<<e,t>,i> (lambda $1:e ($0 $1)))) -> {FACLEX#LEX#298#118=10.000(1.000),FACLEX#TMP#118=0.000(0.100),FACLEX#XEME#298=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#125#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#125=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c) -> {FACLEX#LEX#275#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#275=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#315#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#315=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1)))) -> {FACLEX#LEX#105#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#105=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#410#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#410=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#225#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#225=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross_over :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#159#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#159=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0)) -> {FACLEX#LEX#122#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#122=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: no :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#313#84=10.000(1.000),FACLEX#TMP#84=0.000(0.100),FACLEX#XEME#313=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#250#36=33.484(1.000),FACLEX#TMP#36=0.000(0.100),FACLEX#XEME#250=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#21#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#21=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c) -> {FACLEX#LEX#417#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#417=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0)) -> {FACLEX#LEX#135#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#135=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surround :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#348#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#348=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surround :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#348#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#348=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#284#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#284=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rivers :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#89#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#89=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: runs :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#99#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#99=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: runs :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#99#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#99=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#290#7=10.000(1.000),FACLEX#TMP#7=0.000(0.100),FACLEX#XEME#290=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c) -> {FACLEX#LEX#134#38=10.000(1.000),FACLEX#TMP#38=0.000(0.100),FACLEX#XEME#134=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#215#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#215=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c) -> {FACLEX#LEX#115#81=10.000(1.000),FACLEX#TMP#81=0.000(0.100),FACLEX#XEME#115=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#125#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#125=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: runs :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#157#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#157=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#29#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#29=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#178#10=10.000(1.000),FACLEX#TMP#10=0.000(0.100),FACLEX#XEME#178=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#309#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#309=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#368#95=10.000(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#368=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rivers :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#376#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#376=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbor :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#229#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#229=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#385#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#385=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surrounding :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#289#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#289=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surrounding :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#289#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#289=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2))))) -> {FACLEX#LEX#101#107=10.000(1.000),FACLEX#TMP#107=0.000(0.100),FACLEX#XEME#101=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#323#128=21.435(1.000),FACLEX#TMP#128=0.000(0.100),FACLEX#XEME#323=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2))))) -> {FACLEX#LEX#14#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#14=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#240#112=21.435(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#240=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c) -> {FACLEX#LEX#271#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#271=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#425#135=33.484(1.000),FACLEX#TMP#135=0.000(0.100),FACLEX#XEME#425=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#94#52=10.000(1.000),FACLEX#TMP#52=0.000(0.100),FACLEX#XEME#94=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#8#0=33.484(1.000),FACLEX#TMP#0=0.000(0.100),FACLEX#XEME#8=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#255#68=10.000(1.000),FACLEX#TMP#68=0.000(0.100),FACLEX#XEME#255=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c) -> {FACLEX#LEX#153#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#153=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0)) -> {FACLEX#LEX#167#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#167=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross_over :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#230#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#230=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c) -> {FACLEX#LEX#73#28=10.000(1.000),FACLEX#TMP#28=0.000(0.100),FACLEX#XEME#73=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rivers :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#89#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#89=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: length :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#279#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#279=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#84#3=33.484(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#84=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#218#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#218=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#338#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#338=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#94#19=10.000(1.000),FACLEX#TMP#19=0.000(0.100),FACLEX#XEME#94=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: which :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#38#93=10.000(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#38=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#243#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#243=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#243#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#243=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: borders :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#276#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#276=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: borders :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#276#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#276=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#196#130=21.435(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#196=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#277#30=10.000(1.000),FACLEX#TMP#30=0.000(0.100),FACLEX#XEME#277=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#3#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#3=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: borders :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#310#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#310=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s) -> {FACLEX#LEX#93#53=10.000(1.000),FACLEX#TMP#53=0.000(0.100),FACLEX#XEME#93=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: large :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#190#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#190=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c) -> {FACLEX#LEX#418#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#418=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#66#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#66=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#218#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#218=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbor :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#224#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#224=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0)) -> {FACLEX#LEX#65#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#65=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#177#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#177=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#321#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#321=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#168#26=10.000(1.000),FACLEX#TMP#26=0.000(0.100),FACLEX#XEME#168=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#397#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#397=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#241#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#241=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#241#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#241=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c) -> {FACLEX#LEX#23#12=10.000(1.000),FACLEX#TMP#12=0.000(0.100),FACLEX#XEME#23=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e ($0 $4)))))) -> {FACLEX#LEX#254#76=10.000(1.000),FACLEX#TMP#76=0.000(0.100),FACLEX#XEME#254=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#225#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#225=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0)) -> {FACLEX#LEX#6#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#6=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbor :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $1 $0))) -> {FACLEX#LEX#221#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#221=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c) -> {FACLEX#LEX#61#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#61=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surround :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#171#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#171=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#5#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#5=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#278#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#278=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: borders :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#17#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#17=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#173#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#173=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c) -> {FACLEX#LEX#47#70=10.000(1.000),FACLEX#TMP#70=0.000(0.100),FACLEX#XEME#47=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1)))) -> {FACLEX#LEX#212#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#212=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: are :- S\NP/PP : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#57#29=10.000(1.000),FACLEX#TMP#29=0.000(0.100),FACLEX#XEME#57=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c) -> {FACLEX#LEX#402#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#402=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#21#102=10.000(1.000),FACLEX#TMP#102=0.000(0.100),FACLEX#XEME#21=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#280#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#280=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s) -> {FACLEX#LEX#386#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#386=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: are there :- S\NP : (lambda $0:e true:t) -> {FACLEX#LEX#403#134=21.435(1.000),FACLEX#TMP#134=0.000(0.100),FACLEX#XEME#403=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#345#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#345=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross-over :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#35#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#35=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- S/PP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#19#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#19=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#273#117=10.000(1.000),FACLEX#TMP#117=0.000(0.100),FACLEX#XEME#273=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c) -> {FACLEX#LEX#76#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#76=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: tell me :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#30#78=21.435(1.000),FACLEX#TMP#78=0.000(0.100),FACLEX#XEME#30=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#228#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#228=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#362#132=21.435(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#362=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#280#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#280=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#238#9=21.435(1.000),FACLEX#TMP#9=0.000(0.100),FACLEX#XEME#238=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: what :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#204#93=10.000(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#204=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#101#51=10.000(1.000),FACLEX#TMP#51=0.000(0.100),FACLEX#XEME#101=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#166#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#166=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#55#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#55=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bordering :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#104#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#104=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c) -> {FACLEX#LEX#305#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#305=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross_over :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#230#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#230=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2))))) -> {FACLEX#LEX#257#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#257=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s) -> {FACLEX#LEX#398#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#398=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#387#130=10.000(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#387=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: are :- N\N/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))) -> {FACLEX#LEX#57#101=10.000(1.000),FACLEX#TMP#101=0.000(0.100),FACLEX#XEME#57=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c) -> {FACLEX#LEX#13#55=10.000(1.000),FACLEX#TMP#55=0.000(0.100),FACLEX#XEME#13=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#113#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#113=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: run :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#269#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#269=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: run :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#269#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#269=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: how many :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))) -> {FACLEX#LEX#209#129=21.435(1.000),FACLEX#TMP#129=0.000(0.100),FACLEX#XEME#209=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- N : (lambda $0:e (city:<c_pkey,t> $0)) -> {FACLEX#LEX#350#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#350=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rivers :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#319#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#319=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- S/PP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#128#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#128=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#388#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#388=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c) -> {FACLEX#LEX#349#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#349=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1))) -> {FACLEX#LEX#233#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#233=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#233#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#233=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#284#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#284=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1)))) -> {FACLEX#LEX#112#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#112=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c) -> {FACLEX#LEX#285#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#285=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c) -> {FACLEX#LEX#426#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#426=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#199#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#199=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1)))) -> {FACLEX#LEX#63#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#63=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#86#26=21.435(1.000),FACLEX#TMP#26=0.000(0.100),FACLEX#XEME#86=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surrounds :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#95#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#95=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#262#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#262=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#75#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#75=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#388#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#388=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#332#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#332=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#54#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#54=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbors :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#355#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#355=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: which :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#38#87=10.000(1.000),FACLEX#TMP#87=0.000(0.100),FACLEX#XEME#38=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#277#127=10.000(1.000),FACLEX#TMP#127=0.000(0.100),FACLEX#XEME#277=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#254#116=10.000(1.000),FACLEX#TMP#116=0.000(0.100),FACLEX#XEME#254=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#72#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#72=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0)) -> {FACLEX#LEX#201#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#201=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#82#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#82=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flow :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#371#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#371=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2))))) -> {FACLEX#LEX#242#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#242=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#140#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#140=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#140#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#140=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#56#4=21.435(1.000),FACLEX#TMP#4=0.000(0.100),FACLEX#XEME#56=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#364#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#364=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2))))) -> {FACLEX#LEX#301#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#301=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#45#2=21.435(1.000),FACLEX#TMP#2=0.000(0.100),FACLEX#XEME#45=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: does :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#91#51=10.000(1.000),FACLEX#TMP#51=0.000(0.100),FACLEX#XEME#91=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#365#5=33.484(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#365=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: length :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#85#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#85=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c) -> {FACLEX#LEX#109#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#109=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c) -> {FACLEX#LEX#41#34=10.000(1.000),FACLEX#TMP#34=0.000(0.100),FACLEX#XEME#41=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c) -> {FACLEX#LEX#353#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#353=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#28#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#28=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#258#64=10.000(1.000),FACLEX#TMP#64=0.000(0.100),FACLEX#XEME#258=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $0 $1))) -> {FACLEX#LEX#356#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#356=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<s_pkey,<b_pkey,t>> $1 $0))) -> {FACLEX#LEX#356#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#356=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#236#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#236=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c) -> {FACLEX#LEX#119#6=10.000(1.000),FACLEX#TMP#6=0.000(0.100),FACLEX#XEME#119=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the :- NP/NP : (lambda $0:e $0) -> {FACLEX#LEX#121#99=10.000(1.000),FACLEX#TMP#99=0.000(0.100),FACLEX#XEME#121=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: borders :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#310#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#310=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0))) -> {FACLEX#LEX#256#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#256=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#404#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#404=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c) -> {FACLEX#LEX#235#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#235=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#254#97=10.000(1.000),FACLEX#TMP#97=0.000(0.100),FACLEX#XEME#254=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c) -> {FACLEX#LEX#286#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#286=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0))) -> {FACLEX#LEX#191#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#191=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: can you :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#100#78=21.435(1.000),FACLEX#TMP#78=0.000(0.100),FACLEX#XEME#100=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#31#125=10.000(1.000),FACLEX#TMP#125=0.000(0.100),FACLEX#XEME#31=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: run :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#10#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#10=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2))))) -> {FACLEX#LEX#274#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#274=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s) -> {FACLEX#LEX#287#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#287=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s) -> {FACLEX#LEX#377#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#377=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c) -> {FACLEX#LEX#318#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#318=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#51#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#51=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: run :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#378#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#378=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#175#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#175=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- NP/NP : (lambda $0:e $0) -> {FACLEX#LEX#152#99=10.000(1.000),FACLEX#TMP#99=0.000(0.100),FACLEX#XEME#152=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#333#126=33.484(1.000),FACLEX#TMP#126=0.000(0.100),FACLEX#XEME#333=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: by :- N/N : (lambda $0:<e,e> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#161#74=10.000(1.000),FACLEX#TMP#74=0.000(0.100),FACLEX#XEME#161=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#116#112=10.000(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#116=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#154#66=10.000(1.000),FACLEX#TMP#66=0.000(0.100),FACLEX#XEME#154=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1)))) -> {FACLEX#LEX#29#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#29=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s) -> {FACLEX#LEX#239#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#239=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#44#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#44=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur:c) -> {FACLEX#LEX#351#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#351=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cities :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#182#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#182=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#84#8=33.484(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#84=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#419#130=10.000(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#419=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#385#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#385=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#227#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#227=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c) -> {FACLEX#LEX#83#50=10.000(1.000),FACLEX#TMP#50=0.000(0.100),FACLEX#XEME#83=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c) -> {FACLEX#LEX#217#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#217=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s) -> {FACLEX#LEX#90#43=10.000(1.000),FACLEX#TMP#43=0.000(0.100),FACLEX#XEME#90=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#312#54=45.948(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#312=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0)) -> {FACLEX#LEX#88#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#88=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#307#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#307=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#307#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#307=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#136#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#136=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#420#54=33.484(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#420=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbor :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#229#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#229=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#172#120=21.435(1.000),FACLEX#TMP#120=0.000(0.100),FACLEX#XEME#172=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#405#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#405=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e ($0 $4)))))) -> {FACLEX#LEX#21#76=10.000(1.000),FACLEX#TMP#76=0.000(0.100),FACLEX#XEME#21=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun:c) -> {FACLEX#LEX#352#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#352=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#36#26=21.435(1.000),FACLEX#TMP#26=0.000(0.100),FACLEX#XEME#36=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1)))) -> {FACLEX#LEX#88#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#88=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: runs :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#157#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#157=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1)))) -> {FACLEX#LEX#143#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#143=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#45#20=21.435(1.000),FACLEX#TMP#20=0.000(0.100),FACLEX#XEME#45=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c) -> {FACLEX#LEX#379#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#379=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: not :- PP/PP : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#192#123=10.000(1.000),FACLEX#TMP#123=0.000(0.100),FACLEX#XEME#192=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0)) -> {FACLEX#LEX#143#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#143=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#427#136=33.484(1.000),FACLEX#TMP#136=0.000(0.100),FACLEX#XEME#427=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#137#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#137=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#294#90=10.000(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#294=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#24#66=45.948(1.000),FACLEX#TMP#66=0.000(0.100),FACLEX#XEME#24=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#178#41=10.000(1.000),FACLEX#TMP#41=0.000(0.100),FACLEX#XEME#178=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#149#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#149=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#15#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#15=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1)))) -> {FACLEX#LEX#138#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#138=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#199#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#199=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#64#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#64=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#406#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#406=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#283#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#283=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#283#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#283=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#48#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#48=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1)))) -> {FACLEX#LEX#186#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#186=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s) -> {FACLEX#LEX#326#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#326=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#151#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#151=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#368#130=10.000(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#368=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#268#90=21.435(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#268=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- S/PP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#27#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#27=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kota :- NP : (pkey_retriever:<c,c_pkey> kota:c) -> {FACLEX#LEX#314#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#314=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#315#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#315=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0))) -> {FACLEX#LEX#107#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#107=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#360#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#360=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#288#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#288=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: border :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#302#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#302=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#227#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#227=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#251#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#251=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#162#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#162=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#145#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#145=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#267#131=21.435(1.000),FACLEX#TMP#131=0.000(0.100),FACLEX#XEME#267=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#244#108=33.484(1.000),FACLEX#TMP#108=0.000(0.100),FACLEX#XEME#244=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#331#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#331=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0)) -> {FACLEX#LEX#212#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#212=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#247#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#247=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: area :- NP/PP : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#336#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#336=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#82#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#82=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- S\NP/NP : (lambda $0:e (lambda $1:e (equals:<e,<e,t>> $1 $0))) -> {FACLEX#LEX#80#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#80=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#291#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#291=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: run :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#378#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#378=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#354#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#354=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#77#1=10.000(1.000),FACLEX#TMP#1=0.000(0.100),FACLEX#XEME#77=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#317#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#317=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c) -> {FACLEX#LEX#103#31=10.000(1.000),FACLEX#TMP#31=0.000(0.100),FACLEX#XEME#103=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#354#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#354=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1)))) -> {FACLEX#LEX#6#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#6=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c) -> {FACLEX#LEX#130#46=10.000(1.000),FACLEX#TMP#46=0.000(0.100),FACLEX#XEME#130=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: are :- PP/PP : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#57#82=10.000(1.000),FACLEX#TMP#82=0.000(0.100),FACLEX#XEME#57=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#152#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#152=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#19#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#19=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#97#90=10.000(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#97=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c) -> {FACLEX#LEX#1#13=10.000(1.000),FACLEX#TMP#13=0.000(0.100),FACLEX#XEME#1=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#254#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#254=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#421#105=21.435(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#421=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- S/PP : (lambda $0:e (population:<s_pkey,i> $0)) -> {FACLEX#LEX#113#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#113=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: biggest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#272#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#272=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: area :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#336#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#336=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1))) -> {FACLEX#LEX#297#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#297=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0))) -> {FACLEX#LEX#297#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#297=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c) -> {FACLEX#LEX#156#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#156=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c) -> {FACLEX#LEX#380#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#380=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c) -> {FACLEX#LEX#422#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#422=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#389#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#389=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#173#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#173=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#131#7=10.000(1.000),FACLEX#TMP#7=0.000(0.100),FACLEX#XEME#131=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: do not :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#158#84=21.435(1.000),FACLEX#TMP#84=0.000(0.100),FACLEX#XEME#158=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0)))) -> {FACLEX#LEX#248#110=10.000(1.000),FACLEX#TMP#110=0.000(0.100),FACLEX#XEME#248=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- N : (lambda $0:e (city:<c,t> $0)) -> {FACLEX#LEX#390#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#390=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s) -> {FACLEX#LEX#92#23=21.435(1.000),FACLEX#TMP#23=0.000(0.100),FACLEX#XEME#92=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#291#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#291=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#120#17=10.000(1.000),FACLEX#TMP#17=0.000(0.100),FACLEX#XEME#120=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c) -> {FACLEX#LEX#118#77=10.000(1.000),FACLEX#TMP#77=0.000(0.100),FACLEX#XEME#118=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#296#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#296=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#166#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#166=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#195#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#195=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: sparsest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#203#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#203=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#42#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#42=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2))))) -> {FACLEX#LEX#7#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#7=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- N : (lambda $0:e (next_to:<s_pkey,t> $0)) -> {FACLEX#LEX#249#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#249=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cities :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#160#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#160=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0)) -> {FACLEX#LEX#63#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#63=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#72#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#72=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: length :- S/PP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#85#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#85=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#281#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#281=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: with the :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#11#87=21.435(1.000),FACLEX#TMP#87=0.000(0.100),FACLEX#XEME#11=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#299#128=10.000(1.000),FACLEX#TMP#128=0.000(0.100),FACLEX#XEME#299=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S/NP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#213#51=10.000(1.000),FACLEX#TMP#51=0.000(0.100),FACLEX#XEME#213=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#246#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#246=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c) -> {FACLEX#LEX#142#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#142=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city of :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#259#5=33.484(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#259=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: large :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#40#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#40=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#68#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#68=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#137#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#137=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1)))) -> {FACLEX#LEX#65#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#65=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c) -> {FACLEX#LEX#369#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#369=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi:c) -> {FACLEX#LEX#58#45=10.000(1.000),FACLEX#TMP#45=0.000(0.100),FACLEX#XEME#58=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#251#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#251=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cities :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#160#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#160=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0)))) -> {FACLEX#LEX#31#133=10.000(1.000),FACLEX#TMP#133=0.000(0.100),FACLEX#XEME#31=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S/PP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#34#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#34=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flows :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#214#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#214=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#240#90=21.435(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#240=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#120#44=10.000(1.000),FACLEX#TMP#44=0.000(0.100),FACLEX#XEME#120=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#387#95=10.000(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#387=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0)) -> {FACLEX#LEX#105#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#105=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2)))) -> {FACLEX#LEX#98#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#98=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: what :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))) -> {FACLEX#LEX#204#11=10.000(1.000),FACLEX#TMP#11=0.000(0.100),FACLEX#XEME#204=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon:c) -> {FACLEX#LEX#366#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#366=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#407#132=10.000(1.000),FACLEX#TMP#132=0.000(0.100),FACLEX#XEME#407=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#200#85=33.484(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#200=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#121#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#121=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbors :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#146#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#146=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#334#117=10.000(1.000),FACLEX#TMP#117=0.000(0.100),FACLEX#XEME#334=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur:c) -> {FACLEX#LEX#293#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#293=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city of :- S/PP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#74#3=33.484(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#74=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#48#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#48=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#334#114=10.000(1.000),FACLEX#TMP#114=0.000(0.100),FACLEX#XEME#334=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#126#0=10.000(1.000),FACLEX#TMP#0=0.000(0.100),FACLEX#XEME#126=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#254#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#254=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#394#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#394=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#53#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#53=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#32#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#32=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#325#130=21.435(1.000),FACLEX#TMP#130=0.000(0.100),FACLEX#XEME#325=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2)))) -> {FACLEX#LEX#46#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#46=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0))))) -> {FACLEX#LEX#255#21=10.000(1.000),FACLEX#TMP#21=0.000(0.100),FACLEX#XEME#255=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c) -> {FACLEX#LEX#339#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#339=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#253#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#253=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#411#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#411=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#340#119=10.000(1.000),FACLEX#TMP#119=0.000(0.100),FACLEX#XEME#340=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#53#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#53=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c) -> {FACLEX#LEX#408#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#408=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#392#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#392=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbors :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#146#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#146=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#391#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#391=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c) -> {FACLEX#LEX#370#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#370=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the river :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#223#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#223=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0)) -> {FACLEX#LEX#111#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#111=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1)))) -> {FACLEX#LEX#25#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#25=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0)) -> {FACLEX#LEX#139#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#139=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#392#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#392=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surrounds :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $0 $1))) -> {FACLEX#LEX#329#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#329=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surrounds :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#329#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#329=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan:s) -> {FACLEX#LEX#174#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#174=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: that :- PP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#245#100=10.000(1.000),FACLEX#TMP#100=0.000(0.100),FACLEX#XEME#245=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#345#65=10.000(1.000),FACLEX#TMP#65=0.000(0.100),FACLEX#XEME#345=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#381#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#381=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c) -> {FACLEX#LEX#18#48=10.000(1.000),FACLEX#TMP#48=0.000(0.100),FACLEX#XEME#18=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#360#122=10.000(1.000),FACLEX#TMP#122=0.000(0.100),FACLEX#XEME#360=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#295#120=10.000(1.000),FACLEX#TMP#120=0.000(0.100),FACLEX#XEME#295=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in feet :- S\S : (lambda $0:e $0) -> {FACLEX#LEX#184#109=21.435(1.000),FACLEX#TMP#109=0.000(0.100),FACLEX#XEME#184=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#26#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#26=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c) -> {FACLEX#LEX#413#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#413=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#148#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#148=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: how many :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))) -> {FACLEX#LEX#209#121=21.435(1.000),FACLEX#TMP#121=0.000(0.100),FACLEX#XEME#209=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#316#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#316=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0)) -> {FACLEX#LEX#110#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#110=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#141#4=10.000(1.000),FACLEX#TMP#4=0.000(0.100),FACLEX#XEME#141=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#124#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#124=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1)))) -> {FACLEX#LEX#110#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#110=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#382#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#382=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya_pradesh:s) -> {FACLEX#LEX#133#69=21.435(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#133=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#150#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#150=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#49#17=10.000(1.000),FACLEX#TMP#17=0.000(0.100),FACLEX#XEME#49=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#393#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#393=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0)) -> {FACLEX#LEX#112#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#112=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh:c) -> {FACLEX#LEX#22#40=10.000(1.000),FACLEX#TMP#40=0.000(0.100),FACLEX#XEME#22=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2)))) -> {FACLEX#LEX#254#92=10.000(1.000),FACLEX#TMP#92=0.000(0.100),FACLEX#XEME#254=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: area :- S/PP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#4#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#4=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flows :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#220#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#220=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flows :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#220#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#220=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cities :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#182#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#182=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#147#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#147=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c) -> {FACLEX#LEX#400#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#400=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0)) -> {FACLEX#LEX#234#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#234=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#97#112=10.000(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#97=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#116#90=10.000(1.000),FACLEX#TMP#90=0.000(0.100),FACLEX#XEME#116=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city of :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#74#8=33.484(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#74=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- N : (lambda $0:e (state:<s_pkey,t> $0)) -> {FACLEX#LEX#185#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#185=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#42#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#42=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbors :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#409#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#409=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0)) -> {FACLEX#LEX#32#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#32=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#323#96=21.435(1.000),FACLEX#TMP#96=0.000(0.100),FACLEX#XEME#323=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: lowest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#258#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#258=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: least :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#294#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#294=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#394#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#394=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#78#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#78=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#78#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#78=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: which :- PP/(S/NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#38#100=10.000(1.000),FACLEX#TMP#100=0.000(0.100),FACLEX#XEME#38=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#393#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#393=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the city of :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1)))) -> {FACLEX#LEX#259#103=33.484(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#259=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#187#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#187=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#187#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#187=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c) -> {FACLEX#LEX#12#57=10.000(1.000),FACLEX#TMP#57=0.000(0.100),FACLEX#XEME#12=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flow :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#371#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#371=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flows :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#320#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#320=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#263#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#263=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#428#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#428=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: noida :- NP : (pkey_retriever:<c,c_pkey> noida:c) -> {FACLEX#LEX#81#25=10.000(1.000),FACLEX#TMP#25=0.000(0.100),FACLEX#XEME#81=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#255#61=10.000(1.000),FACLEX#TMP#61=0.000(0.100),FACLEX#XEME#255=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: please :- S/S : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#188#78=10.000(1.000),FACLEX#TMP#78=0.000(0.100),FACLEX#XEME#188=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#395#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#395=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#106#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#106=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#321#97=10.000(1.000),FACLEX#TMP#97=0.000(0.100),FACLEX#XEME#321=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: please :- S\S : (lambda $0:e $0) -> {FACLEX#LEX#188#109=10.000(1.000),FACLEX#TMP#109=0.000(0.100),FACLEX#XEME#188=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#423#54=21.435(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#423=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s) -> {FACLEX#LEX#414#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#414=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: reewa :- NP : (pkey_retriever:<c,c_pkey> reewa:c) -> {FACLEX#LEX#169#33=10.000(1.000),FACLEX#TMP#33=0.000(0.100),FACLEX#XEME#169=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2)))) -> {FACLEX#LEX#218#89=10.000(1.000),FACLEX#TMP#89=0.000(0.100),FACLEX#XEME#218=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (area:<s_pkey,i> $2)))) -> {FACLEX#LEX#59#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#59=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#101#104=10.000(1.000),FACLEX#TMP#104=0.000(0.100),FACLEX#XEME#101=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flows :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#214#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#214=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#395#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#395=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#37#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#37=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: not :- N/N : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1)))) -> {FACLEX#LEX#192#94=10.000(1.000),FACLEX#TMP#94=0.000(0.100),FACLEX#XEME#192=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar_pradesh:s) -> {FACLEX#LEX#62#59=21.435(1.000),FACLEX#TMP#59=0.000(0.100),FACLEX#XEME#62=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cities :- S\NP/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0))) -> {FACLEX#LEX#237#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#237=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (length:<r_pkey,i> $2)))) -> {FACLEX#LEX#372#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#372=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: show :- S/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#193#67=10.000(1.000),FACLEX#TMP#67=0.000(0.100),FACLEX#XEME#193=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1)))) -> {FACLEX#LEX#201#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#201=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#391#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#391=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#260#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#260=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: how many :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#71#93=21.435(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#71=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flows :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#320#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#320=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1)))) -> {FACLEX#LEX#79#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#79=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra:s) -> {FACLEX#LEX#373#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#373=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#330#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#330=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#123#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#123=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#365#103=33.484(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#365=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur:c) -> {FACLEX#LEX#0#35=10.000(1.000),FACLEX#TMP#35=0.000(0.100),FACLEX#XEME#0=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#196#95=21.435(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#196=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1)))) -> {FACLEX#LEX#43#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#43=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2))))) -> {FACLEX#LEX#117#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#117=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: river :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#132#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#132=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbors :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#409#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#409=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal:c) -> {FACLEX#LEX#211#18=10.000(1.000),FACLEX#TMP#18=0.000(0.100),FACLEX#XEME#211=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#170#42=10.000(1.000),FACLEX#TMP#42=0.000(0.100),FACLEX#XEME#170=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#124#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#124=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c) -> {FACLEX#LEX#322#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#322=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#252#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#252=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#67#14=10.000(1.000),FACLEX#TMP#14=0.000(0.100),FACLEX#XEME#67=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S\NP/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#207#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#207=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#20#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#20=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#263#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#263=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: live :- S\NP/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#198#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#198=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#412#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#412=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#106#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#106=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#341#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#341=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flow :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#210#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#210=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flow :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#210#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#210=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1)))) -> {FACLEX#LEX#123#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#123=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#149#19=10.000(1.000),FACLEX#TMP#19=0.000(0.100),FACLEX#XEME#149=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand:s) -> {FACLEX#LEX#176#24=10.000(1.000),FACLEX#TMP#24=0.000(0.100),FACLEX#XEME#176=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c) -> {FACLEX#LEX#374#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#374=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1)))) -> {FACLEX#LEX#33#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#33=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#401#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#401=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#43#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#43=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0)) -> {FACLEX#LEX#33#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#33=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#27#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#27=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#164#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#164=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#164#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#164=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flow :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#144#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#144=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0)))) -> {FACLEX#LEX#270#115=10.000(1.000),FACLEX#TMP#115=0.000(0.100),FACLEX#XEME#270=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#15#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#15=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#129#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#129=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: with :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2))))) -> {FACLEX#LEX#231#107=10.000(1.000),FACLEX#TMP#107=0.000(0.100),FACLEX#XEME#231=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) (lambda $4:e (size:<lo,i> $4)))))) -> {FACLEX#LEX#60#15=10.000(1.000),FACLEX#TMP#15=0.000(0.100),FACLEX#XEME#60=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1)))) -> {FACLEX#LEX#135#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#135=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#64#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#64=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal:c) -> {FACLEX#LEX#265#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#265=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#311#124=10.000(1.000),FACLEX#TMP#124=0.000(0.100),FACLEX#XEME#311=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (elevation:<lo,i> $2)))) -> {FACLEX#LEX#124#64=10.000(1.000),FACLEX#TMP#64=0.000(0.100),FACLEX#XEME#124=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#226#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#226=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: that :- PP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#245#87=10.000(1.000),FACLEX#TMP#87=0.000(0.100),FACLEX#XEME#245=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: a :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#208#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#208=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2))))) -> {FACLEX#LEX#222#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#222=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- S/S : (lambda $0:t $0) -> {FACLEX#LEX#101#37=10.000(1.000),FACLEX#TMP#37=0.000(0.100),FACLEX#XEME#101=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar:c) -> {FACLEX#LEX#342#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#342=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#415#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#415=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#136#3=21.435(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#136=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon:c) -> {FACLEX#LEX#424#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#424=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#266#85=21.435(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#266=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: area :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#4#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#4=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa:c) -> {FACLEX#LEX#2#63=10.000(1.000),FACLEX#TMP#63=0.000(0.100),FACLEX#XEME#2=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur:c) -> {FACLEX#LEX#383#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#383=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra:c) -> {FACLEX#LEX#399#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#399=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: river :- N : (lambda $0:e (river:<r,t> $0)) -> {FACLEX#LEX#343#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#343=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#411#103=21.435(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#411=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0)))) -> {FACLEX#LEX#267#113=21.435(1.000),FACLEX#TMP#113=0.000(0.100),FACLEX#XEME#267=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: run :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#10#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#10=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#268#112=21.435(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#268=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow:c) -> {FACLEX#LEX#127#16=10.000(1.000),FACLEX#TMP#16=0.000(0.100),FACLEX#XEME#127=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#181#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#181=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0)))) -> {FACLEX#LEX#77#56=10.000(1.000),FACLEX#TMP#56=0.000(0.100),FACLEX#XEME#77=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: what :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2))))) -> {FACLEX#LEX#204#62=10.000(1.000),FACLEX#TMP#62=0.000(0.100),FACLEX#XEME#204=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh:c) -> {FACLEX#LEX#357#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#357=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- N : (lambda $0:e (state:<s,t> $0)) -> {FACLEX#LEX#324#91=10.000(1.000),FACLEX#TMP#91=0.000(0.100),FACLEX#XEME#324=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- N/N : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#101#83=10.000(1.000),FACLEX#TMP#83=0.000(0.100),FACLEX#XEME#101=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- S/NP : (lambda $0:e (population:<lo,i> $0)) -> {FACLEX#LEX#102#49=10.000(1.000),FACLEX#TMP#49=0.000(0.100),FACLEX#XEME#102=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#21#71=10.000(1.000),FACLEX#TMP#71=0.000(0.100),FACLEX#XEME#21=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: katni :- NP : (pkey_retriever:<c,c_pkey> katni:c) -> {FACLEX#LEX#303#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#303=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#66#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#66=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (population:<c_pkey,i> $2)))) -> {FACLEX#LEX#124#97=10.000(1.000),FACLEX#TMP#97=0.000(0.100),FACLEX#XEME#124=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#206#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#206=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#206#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#206=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0)) -> {FACLEX#LEX#39#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#39=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#381#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#381=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#299#96=10.000(1.000),FACLEX#TMP#96=0.000(0.100),FACLEX#XEME#299=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#26#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#26=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#415#5=21.435(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#415=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the :- NP/N : (lambda $0:<e,t> (the:<<e,t>,e> (lambda $1:e ($0 $1)))) -> {FACLEX#LEX#121#98=10.000(1.000),FACLEX#TMP#98=0.000(0.100),FACLEX#XEME#121=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1)))) -> {FACLEX#LEX#234#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#234=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: flow :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#144#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#144=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: surrounding :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#50#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#50=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#382#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#382=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana:s) -> {FACLEX#LEX#396#69=45.948(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#396=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: length :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#327#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#327=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0)) -> {FACLEX#LEX#25#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#25=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: please :- S\S : (lambda $0:t $0) -> {FACLEX#LEX#188#106=10.000(1.000),FACLEX#TMP#106=0.000(0.100),FACLEX#XEME#188=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#96#32=10.000(1.000),FACLEX#TMP#32=0.000(0.100),FACLEX#XEME#96=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s) -> {FACLEX#LEX#232#47=10.000(1.000),FACLEX#TMP#47=0.000(0.100),FACLEX#XEME#232=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1)))) -> {FACLEX#LEX#139#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#139=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#419#95=10.000(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#419=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: patna :- NP : (pkey_retriever:<c,c_pkey> patna:c) -> {FACLEX#LEX#189#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#189=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: in meters :- S\S : (lambda $0:e $0) -> {FACLEX#LEX#202#109=21.435(1.000),FACLEX#TMP#109=0.000(0.100),FACLEX#XEME#202=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#163#7=10.000(1.000),FACLEX#TMP#7=0.000(0.100),FACLEX#XEME#163=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#108#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#108=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1)))) -> {FACLEX#LEX#122#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#122=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#358#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#358=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: combined :- NP\N\N : (lambda $0:<e,t> (lambda $1:<e,e> (sum:<<e,t>,<<e,i>,i>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#306#80=10.000(1.000),FACLEX#TMP#80=0.000(0.100),FACLEX#XEME#306=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#295#119=10.000(1.000),FACLEX#TMP#119=0.000(0.100),FACLEX#XEME#295=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1)))) -> {FACLEX#LEX#401#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#401=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: does :- S\NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e ($0 $1))) -> {FACLEX#LEX#91#104=10.000(1.000),FACLEX#TMP#104=0.000(0.100),FACLEX#XEME#91=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0)) -> {FACLEX#LEX#37#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#37=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#261#79=33.484(1.000),FACLEX#TMP#79=0.000(0.100),FACLEX#XEME#261=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rivers :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#376#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#376=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: area :- S\NP/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#69#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#69=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0)))) -> {FACLEX#LEX#16#58=10.000(1.000),FACLEX#TMP#58=0.000(0.100),FACLEX#XEME#16=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0)) -> {FACLEX#LEX#155#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#155=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#325#95=21.435(1.000),FACLEX#TMP#95=0.000(0.100),FACLEX#XEME#325=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- NP/N/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($0 $2)) (lambda $3:e ($1 $3))))) -> {FACLEX#LEX#321#111=10.000(1.000),FACLEX#TMP#111=0.000(0.100),FACLEX#XEME#321=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0))))) -> {FACLEX#LEX#335#21=10.000(1.000),FACLEX#TMP#21=0.000(0.100),FACLEX#XEME#335=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $1:e ($0 $1)) (lambda $2:e (size:<lo,i> $2)))) -> {FACLEX#LEX#254#71=10.000(1.000),FACLEX#TMP#71=0.000(0.100),FACLEX#XEME#254=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: total :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (sum:<<e,t>,<<e,i>,i>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#183#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#183=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#367#105=10.000(1.000),FACLEX#TMP#105=0.000(0.100),FACLEX#XEME#367=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#282#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#282=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2))))) -> {FACLEX#LEX#70#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#70=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nainital :- NP : (pkey_retriever:<c,c_pkey> nainital:c) -> {FACLEX#LEX#384#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#384=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad:c) -> {FACLEX#LEX#359#72=21.435(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#359=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0)) -> {FACLEX#LEX#34#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#34=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: has :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2))))) -> {FACLEX#LEX#304#60=10.000(1.000),FACLEX#TMP#60=0.000(0.100),FACLEX#XEME#304=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: runs :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1)))) -> {FACLEX#LEX#361#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#361=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: neighbor :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#346#5=10.000(1.000),FACLEX#TMP#5=0.000(0.100),FACLEX#XEME#346=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross-over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1))) -> {FACLEX#LEX#308#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#308=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross-over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#308#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#308=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross_over :- S/PP : (lambda $0:e (river:<r_pkey,r> $0)) -> {FACLEX#LEX#159#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#159=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#273#114=10.000(1.000),FACLEX#TMP#114=0.000(0.100),FACLEX#XEME#273=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#335#61=10.000(1.000),FACLEX#TMP#61=0.000(0.100),FACLEX#XEME#335=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: cross_over :- S\NP/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0))) -> {FACLEX#LEX#205#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#205=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0)) -> {FACLEX#LEX#186#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#186=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga:c) -> {FACLEX#LEX#328#72=10.000(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#328=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: how :- S/NP : (lambda $0:e $0) -> {FACLEX#LEX#165#93=10.000(1.000),FACLEX#TMP#93=0.000(0.100),FACLEX#XEME#165=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: most :- NP/N/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $2:e ($1 $2)) (lambda $3:e ($0 $3))))) -> {FACLEX#LEX#116#22=10.000(1.000),FACLEX#TMP#22=0.000(0.100),FACLEX#XEME#116=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- NP/NP : (lambda $0:e $0) -> {FACLEX#LEX#101#99=10.000(1.000),FACLEX#TMP#99=0.000(0.100),FACLEX#XEME#101=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#172#119=21.435(1.000),FACLEX#TMP#119=0.000(0.100),FACLEX#XEME#172=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: longer :- PP/NP/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0))))) -> {FACLEX#LEX#67#21=10.000(1.000),FACLEX#TMP#21=0.000(0.100),FACLEX#XEME#67=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1)))) -> {FACLEX#LEX#167#75=10.000(1.000),FACLEX#TMP#75=0.000(0.100),FACLEX#XEME#167=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c) -> {FACLEX#LEX#114#39=10.000(1.000),FACLEX#TMP#39=0.000(0.100),FACLEX#XEME#114=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: are :- NP\N/(NP/N) : (lambda $0:<<e,t>,e> (lambda $1:<e,t> ($0 (lambda $2:e ($1 $2))))) -> {FACLEX#LEX#57#107=10.000(1.000),FACLEX#TMP#107=0.000(0.100),FACLEX#XEME#57=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: at least one :- S\NP\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i)))) -> {FACLEX#LEX#197#88=33.484(1.000),FACLEX#TMP#88=0.000(0.100),FACLEX#XEME#197=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand:s) -> {FACLEX#LEX#300#69=10.000(1.000),FACLEX#TMP#69=0.000(0.100),FACLEX#XEME#300=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2))))) -> {FACLEX#LEX#87#73=10.000(1.000),FACLEX#TMP#73=0.000(0.100),FACLEX#XEME#87=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1))) -> {FACLEX#LEX#9#86=10.000(1.000),FACLEX#TMP#86=0.000(0.100),FACLEX#XEME#9=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: have :- S\NP/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0))) -> {FACLEX#LEX#9#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#9=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0)) -> {FACLEX#LEX#79#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#79=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: city named mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai:c) -> {FACLEX#LEX#264#72=33.484(1.000),FACLEX#TMP#72=0.000(0.100),FACLEX#XEME#264=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: length :- NP/PP : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1)))) -> {FACLEX#LEX#327#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#327=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0)))) -> {FACLEX#LEX#149#52=10.000(1.000),FACLEX#TMP#52=0.000(0.100),FACLEX#XEME#149=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: high :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0)) -> {FACLEX#LEX#52#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#52=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: state :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0))) -> {FACLEX#LEX#180#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#180=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: next_to :- NP/PP : (lambda $0:<e,t> (lambda $1:e (next_to:<b_pkey,<t,s_pkey>> $1 ($0 $1)))) -> {FACLEX#LEX#358#103=10.000(1.000),FACLEX#TMP#103=0.000(0.100),FACLEX#XEME#358=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bihar :- NP : (pkey_retriever:<s,s_pkey> bihar:s) -> {FACLEX#LEX#416#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#416=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: long :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0)) -> {FACLEX#LEX#219#8=10.000(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#219=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie:c) -> {FACLEX#LEX#375#54=10.000(1.000),FACLEX#TMP#54=0.000(0.100),FACLEX#XEME#375=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: is :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0)) -> {FACLEX#LEX#138#27=10.000(1.000),FACLEX#TMP#27=0.000(0.100),FACLEX#XEME#138=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: borders :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0)) -> {FACLEX#LEX#17#3=10.000(1.000),FACLEX#TMP#3=0.000(0.100),FACLEX#XEME#17=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: states :- S\NP/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0))) -> {FACLEX#LEX#179#85=10.000(1.000),FACLEX#TMP#85=0.000(0.100),FACLEX#XEME#179=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0)) -> {FACLEX#LEX#68#8=21.435(1.000),FACLEX#TMP#8=0.000(0.100),FACLEX#XEME#68=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e ($2 $3)) (lambda $4:e (count:<<e,t>,i> (lambda $5:e (and:<t*,t> ($0 $5) ($1 $5 $4))))))))) -> {FACLEX#LEX#294#112=10.000(1.000),FACLEX#TMP#112=0.000(0.100),FACLEX#XEME#294=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: aurangabad :- NP : aurangabad:c -> {FACLEX#LEX#341#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#341=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: gurgaon :- NP : gurgaon:c -> {FACLEX#LEX#153#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#153=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra :- NP : maharashtra:s -> {FACLEX#LEX#147#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#147=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kanpur :- NP : kanpur:c -> {FACLEX#LEX#374#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#374=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: haryana :- NP : haryana:s -> {FACLEX#LEX#260#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#260=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nagpur :- NP : nagpur:c -> {FACLEX#LEX#271#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#271=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rishikesh :- NP : rishikesh:c -> {FACLEX#LEX#142#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#142=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: reewa :- NP : reewa:c -> {FACLEX#LEX#286#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#286=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: katni :- NP : katni:c -> {FACLEX#LEX#303#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#303=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: rajasthan :- NP : rajasthan:s -> {FACLEX#LEX#398#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#398=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: dehradun :- NP : dehradun:c -> {FACLEX#LEX#349#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#349=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhusawal :- NP : bhusawal:c -> {FACLEX#LEX#408#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#408=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: darbhanga :- NP : darbhanga:c -> {FACLEX#LEX#328#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#328=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: nainital :- NP : nainital:c -> {FACLEX#LEX#402#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#402=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttrakhand :- NP : uttrakhand:s -> {FACLEX#LEX#300#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#300=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the state of haryana :- NP : haryana:s -> {FACLEX#LEX#396#137=45.948(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#396=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: madhya pradesh :- NP : madhya_pradesh:s -> {FACLEX#LEX#133#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#133=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kurukshetra :- NP : kurukshetra:c -> {FACLEX#LEX#399#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#399=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: noida :- NP : noida:c -> {FACLEX#LEX#339#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#339=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jalgaon :- NP : jalgaon:c -> {FACLEX#LEX#353#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#353=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: maharashtra state :- NP : maharashtra:s -> {FACLEX#LEX#332#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#332=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mussoorie :- NP : mussoorie:c -> {FACLEX#LEX#379#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#379=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the maharashtra :- NP : maharashtra:s -> {FACLEX#LEX#253#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#253=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: the aurangabad :- NP : aurangabad:c -> {FACLEX#LEX#359#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#359=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bhopal :- NP : bhopal:c -> {FACLEX#LEX#318#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#318=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: kota :- NP : kota:c -> {FACLEX#LEX#305#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#305=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: khandwa :- NP : khandwa:c -> {FACLEX#LEX#275#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#275=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: deoghar :- NP : deoghar:c -> {FACLEX#LEX#235#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#235=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jodhpur :- NP : jodhpur:c -> {FACLEX#LEX#109#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#109=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: uttar pradesh :- NP : uttar_pradesh:s -> {FACLEX#LEX#239#137=21.435(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#239=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jharkhand :- NP : jharkhand:s -> {FACLEX#LEX#216#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#216=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: jaipur :- NP : jaipur:c -> {FACLEX#LEX#369#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#369=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: patna :- NP : patna:c -> {FACLEX#LEX#189#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#189=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: chandigarh :- NP : chandigarh:c -> {FACLEX#LEX#357#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#357=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: ranchi :- NP : ranchi:c -> {FACLEX#LEX#217#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#217=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: mumbai :- NP : mumbai:c -> {FACLEX#LEX#247#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#247=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: luckhnow :- NP : luckhnow:c -> {FACLEX#LEX#363#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#363=10.000(1.000)}
[P-T2] [P-T2] Init FACLEX#XEME: bihar :- NP : bihar:s -> {FACLEX#LEX#326#137=10.000(1.000),FACLEX#TMP#137=0.000(0.100),FACLEX#XEME#326=10.000(1.000)}
