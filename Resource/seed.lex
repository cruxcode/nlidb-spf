//Testing: plural
//states :- NP/PP : (lambda $0:<e,t> (a:<<e,t>,e> (lambda $1:e (and:<t*,t> (state:<s,t> $1) ($0 $1)))))
//states :- NP : (a:<<e,t>,e> (lambda $0:e (state:<s,t> $0)))
//states :- NP\(N/N) : (lambda $0:<<e,t>,<e,t>> (a:<<e,t>,e> ($0 (lambda $1:e (state:<s,t> $1)))))

//wh-words
show :- S/N : (lambda $0:<e,t> $0)
what :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
what :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
how many :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
how many :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
how many :- S/(S\NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
how many :- S/(S/NP)/N : (lambda $0:<e,t> (lambda $1:<e,t> (count:<<e,t>,i> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
//how many :- S/N : (lambda $0:<e,t> (count:<<e,t>,i> $0))
which :- S/NP : (lambda $0:e $0)
how many :- S/NP : (lambda $0:e $0)
how :- S/NP : (lambda $0:e $0)
what :- S/NP : (lambda $0:e $0)
//where :- S/NP : (lambda $0:e (lambda $1:e (loc:<lo,<lo,t>> $0 $1)))

// <e,t> nouns

// <e,i> nouns


// active verb


// passive verb - Texas has Austin
 
//contains :- (S\NP)/NP : (lambda $0:e (lambda $1:e (loc:<lo,<lo,t>> $0 $1)))  

//preposition


//adjective


// for eliptical sentences such as "states bordering texas"

number :- S/N : (lambda $0:<e,t> (count:<<e,t>,i> $0))
// for "sentences" such as "population of seattle"
population :- S/NP : (lambda $0:e (population:<lo,i> $0))

//determiners
the :- N/N : (lambda $0:<e,t> $0)
is :- N/N : (lambda $0:<e,t> $0)
a :- N/N : (lambda $0:<e,t> $0)
of :- N/N : (lambda $0:<e,t> $0)
the :- NP/NP : (lambda $0:e $0)
is :- NP/NP : (lambda $0:e $0)
of :- NP/NP : (lambda $0:e $0)
the :- NP/N : (lambda $0:<e,t> (the:<<e,t>,e> $0))

that :- PP/(S\NP) : (lambda $0:<e,t> $0)
that :- PP/(S/NP) : (lambda $0:<e,t> $0)
which :- PP/(S\NP) : (lambda $0:<e,t> $0)
which :- PP/(S/NP) : (lambda $0:<e,t> $0)
are :- PP/PP : (lambda $0:<e,t> $0)

// for "state with the capital des moines"
with the :- PP/(S\NP) : (lambda $0:<e,t> $0)


// for "populations of the states .."


// for "what is the population of seattle"


// copula, etc.
are :- (N\N)/N : (lambda $0:<e,t> (lambda $1:<e,t> (lambda $2:e (and:<t*,t> ($0 $2) ($1 $2)))))
are :- (S\NP)/PP : (lambda $0:<e,t> $0)
does :- (S/NP)/(S/NP) : (lambda $0:<e,t> $0)
does :- (S\NP)/(S\NP) : (lambda $0:<e,t> $0)
// what state is dallas in
//is :- ((S\NP)/(PP/NP))/NP : (lambda $0:e (lambda $1:<e,<e,t>> (lambda $2:e ($1 $2 $0))))
is :- (S/NP)/(S/NP) : (lambda $0:<e,t> $0)
have :- (S/NP)/(S/NP) : (lambda $0:<e,t> $0)
is :- (S\NP)/(S\NP) : (lambda $0:<e,t> $0)
are there :- S\NP : (lambda $0:e true:t)
is :- (S\NP)/NP : (lambda $0:e (lambda $1:e (equals:<e,<e,t>> $1 $0)))

// negation
not :- N/N : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
not :- PP/PP : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
do not :- (S\NP)/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
no :- (S\NP)/(S\NP) : (lambda $0:<e,t> (lambda $1:e (not:<t,t> ($0 $1))))
excluding :- PP/NP : (lambda $0:e (lambda $1:e (not:<t,t> (equals:<e,<e,t>> $1 $0))))
//no :- (S\NP)\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (not:<t,t> ($1 (a:<<e,t>,e> $0) $2)))))

// empty sentence modifier
tell me :- S/S : (lambda $0:<e,t> $0)
can you  :- S/S : (lambda $0:<e,t> $0)
please  :- S/S : (lambda $0:<e,t> $0)
please :- S\S : (lambda $0:e $0)
please :- S\S : (lambda $0:t $0)
in feet :- S\S : (lambda $0:e $0)
in meters :- S\S : (lambda $0:e $0)
is :- S/S : (lambda $0:t $0)


has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
live :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
live :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
live :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
live :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
borders :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
borders :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
bordering :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
bordering :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
border :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
border :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
surrounds :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
surrounds :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
surrounding :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
surrounding :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
surround :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
surround :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
borders :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
borders :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
bordering :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
bordering :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
border :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
border :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
surrounds :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
surrounds :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
surrounding :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
surrounding :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
surround :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $0 $1)))
surround :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0))
state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0))
state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0)))
state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<s_pkey,<t,s>> $1 ($0 $1))))
state :- N : state:<s,t>
city :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
city :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
city :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0)))
city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1))))
city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<s_pkey,<t,c_pkey>> $1 ($0 $1))))
city :- N : city:<c_pkey,t>
area :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
area :- S/PP : (lambda $0:e (area:<s_pkey,i> $0))
area :- (S\NP)/NP : (lambda $0:e (lambda $1:e (area:<s_pkey,<i,t>> $1 $0)))
area :- NP/PP : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1))))
area :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (area:<s_pkey,<t,i>> $1 ($0 $1))))
population :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0))
population :- S/PP : (lambda $0:e (population:<s_pkey,i> $0))
population :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0)))
population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1))))
population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<s_pkey,<t,i>> $1 ($0 $1))))
river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
river :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<r_pkey,<t,r>> $1 ($0 $1))))
river :- N : river:<r,t>
state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0)))
state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<r_pkey,<t,s_pkey>> $1 ($0 $1))))
state :- N : state:<s_pkey,t>
length :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
length :- S/PP : (lambda $0:e (length:<r_pkey,i> $0))
length :- (S\NP)/NP : (lambda $0:e (lambda $1:e (length:<r_pkey,<i,t>> $1 $0)))
length :- NP/PP : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1))))
length :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (length:<r_pkey,<t,i>> $1 ($0 $1))))
city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0))
city :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<c_pkey,<t,c>> $1 ($0 $1))))
city :- N : city:<c,t>
state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0)))
state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<c_pkey,<t,s_pkey>> $1 ($0 $1))))
state :- N : state:<s_pkey,t>
population :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
population :- S/PP : (lambda $0:e (population:<c_pkey,i> $0))
population :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<c_pkey,<i,t>> $1 $0)))
population :- NP/PP : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1))))
population :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (population:<c_pkey,<t,i>> $1 ($0 $1))))
state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0)))
state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s_pkey>> $1 ($0 $1))))
state :- N : state:<s_pkey,t>
state :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
state :- S/PP : (lambda $0:e (state:<b_pkey,s> $0))
state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $1 $0)))
state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s>> $1 ($0 $1))))
state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<b_pkey,<t,s>> $1 ($0 $1))))
state :- N : state:<s,t>
states :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0))
states :- S/PP : (lambda $0:e (state:<s_pkey,s> $0))
states :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0)))
the state :- NP/NP : (lambda $0:e (state:<s_pkey,s> $0))
the state :- S/PP : (lambda $0:e (state:<s_pkey,s> $0))
the state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<s_pkey,<s,t>> $1 $0)))
cities :- NP/NP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
cities :- S/PP : (lambda $0:e (city:<s_pkey,c_pkey> $0))
cities :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<s_pkey,<c_pkey,t>> $1 $0)))
live :- NP/NP : (lambda $0:e (population:<s_pkey,i> $0))
live :- S/PP : (lambda $0:e (population:<s_pkey,i> $0))
live :- (S\NP)/NP : (lambda $0:e (lambda $1:e (population:<s_pkey,<i,t>> $1 $0)))
rivers :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
rivers :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
rivers :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
the river :- NP/NP : (lambda $0:e (river:<r_pkey,r> $0))
the river :- S/PP : (lambda $0:e (river:<r_pkey,r> $0))
the river :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<r_pkey,<r,t>> $1 $0)))
states :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
states :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
states :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0)))
the state :- NP/NP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
the state :- S/PP : (lambda $0:e (state:<r_pkey,s_pkey> $0))
the state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<r_pkey,<s_pkey,t>> $1 $0)))
the city :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
the city :- S/PP : (lambda $0:e (city:<c_pkey,c> $0))
the city :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
the city of :- NP/NP : (lambda $0:e (city:<c_pkey,c> $0))
the city of :- S/PP : (lambda $0:e (city:<c_pkey,c> $0))
the city of :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<c_pkey,<c,t>> $1 $0)))
states :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
states :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
states :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0)))
the state :- NP/NP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
the state :- S/PP : (lambda $0:e (state:<c_pkey,s_pkey> $0))
the state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<c_pkey,<s_pkey,t>> $1 $0)))
the state :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
the state :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
the state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0)))
the state of :- NP/NP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
the state of :- S/PP : (lambda $0:e (state:<b_pkey,s_pkey> $0))
the state of :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s_pkey,t>> $1 $0)))
next_to :- NP/NP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
next_to :- S/PP : (lambda $0:e (next_to:<b_pkey,s_pkey> $0))
next_to :- (S\NP)/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s_pkey,t>> $1 $0)))
states :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
states :- S/PP : (lambda $0:e (state:<b_pkey,s> $0))
states :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $1 $0)))
the state :- NP/NP : (lambda $0:e (state:<b_pkey,s> $0))
the state :- S/PP : (lambda $0:e (state:<b_pkey,s> $0))
the state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<b_pkey,<s,t>> $1 $0)))
next_to :- NP/NP : (lambda $0:e (next_to:<b_pkey,s> $0))
next_to :- S/PP : (lambda $0:e (next_to:<b_pkey,s> $0))
next_to :- (S\NP)/NP : (lambda $0:e (lambda $1:e (next_to:<b_pkey,<s,t>> $1 $0)))
large :- NP/NP : (lambda $0:e (area:<s_pkey,i> $0))
larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 area:<s_pkey,i>))
larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<s_pkey,i> $1) (area:<s_pkey,i> $0))))
larger :- (PP/NP)/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 area:<s_pkey,i>))
largest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
largest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
large :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 population:<c_pkey,i>))
larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
larger :- (PP/NP)/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 population:<c_pkey,i>))
largest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
largest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
higher :- (PP/NP)/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 population:<c_pkey,i>))
highest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
highest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
long :- NP/NP : (lambda $0:e (length:<r_pkey,i> $0))
longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 length:<r_pkey,i>))
longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<r_pkey,i> $1) (length:<r_pkey,i> $0))))
longer :- (PP/NP)/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 length:<r_pkey,i>))
longest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
longest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
high :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
higher :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (population:<c_pkey,i> $1) (population:<c_pkey,i> $0))))
higher :- (PP/NP)/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 population:<c_pkey,i>))
highest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
highest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
large :- NP/NP : (lambda $0:e (population:<c_pkey,i> $0))
larger :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 population:<c_pkey,i>))
larger :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
larger :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 population:<c_pkey,i>))
largest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
largest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
in :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<s,s_pkey> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,s_pkey> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<s,t>> $1 ($0 $2)))))
has :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1))))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2)))))
have :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1))))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2)))))
has :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1))))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2)))))
have :- PP/NP : (lambda $0:e (pkey_retriever:<i,s_pkey> $0))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,s_pkey> ($0 $1))))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:s_pkey (lambda $2:e (set_retriever:<s_pkey,<i,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<r,r_pkey> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<r,r_pkey> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<r,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,r_pkey> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,r_pkey> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<s_pkey,t>> $1 ($0 $2)))))
has :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1))))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2)))))
have :- PP/NP : (lambda $0:e (pkey_retriever:<i,r_pkey> $0))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,r_pkey> ($0 $1))))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:r_pkey (lambda $2:e (set_retriever:<r_pkey,<i,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<c,c_pkey> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<c,c_pkey> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<c,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,c_pkey> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,c_pkey> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<s_pkey,t>> $1 ($0 $2)))))
has :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1))))
has :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2)))))
have :- PP/NP : (lambda $0:e (pkey_retriever:<i,c_pkey> $0))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<i,c_pkey> ($0 $1))))
have :- PP/NP : (lambda $0:<e,e> (lambda $1:c_pkey (lambda $2:e (set_retriever:<c_pkey,<i,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<s_pkey,b_pkey> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s_pkey,b_pkey> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s_pkey,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<s,b_pkey> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,b_pkey> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<s,b_pkey> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,b_pkey> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<s,b_pkey> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<s,b_pkey> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:b_pkey (lambda $2:e (set_retriever:<b_pkey,<s,t>> $1 ($0 $2)))))

maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
madhya pradesh :- NP : (pkey_retriever:<s,s_pkey> madhya pradesh)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
rajasthan :- NP : (pkey_retriever:<s,s_pkey> rajasthan)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
jharkhand :- NP : (pkey_retriever:<s,s_pkey> jharkhand)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
uttar pradesh :- NP : (pkey_retriever:<s,s_pkey> uttar pradesh)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
uttrakhand :- NP : (pkey_retriever:<s,s_pkey> uttrakhand)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
bihar :- NP : (pkey_retriever:<s,s_pkey> bihar)
the maharashtra :- NP : (pkey_retriever:<s,s_pkey> maharashtra)
the state of haryana :- NP : (pkey_retriever:<s,s_pkey> haryana)
maharashtra state :- NP : (pkey_retriever:<s,s_pkey> maharashtra)

aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
mumbai :- NP : (pkey_retriever:<c,c_pkey> mumbai)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
jalgaon :- NP : (pkey_retriever:<c,c_pkey> jalgaon)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
bhusawal :- NP : (pkey_retriever:<c,c_pkey> bhusawal)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
nagpur :- NP : (pkey_retriever:<c,c_pkey> nagpur)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
kurukshetra :- NP : (pkey_retriever:<c,c_pkey> kurukshetra)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
gurgaon :- NP : (pkey_retriever:<c,c_pkey> gurgaon)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
chandigarh :- NP : (pkey_retriever:<c,c_pkey> chandigarh)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
ranchi :- NP : (pkey_retriever:<c,c_pkey> ranchi)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
deoghar :- NP : (pkey_retriever:<c,c_pkey> deoghar)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
kanpur :- NP : (pkey_retriever:<c,c_pkey> kanpur)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
noida :- NP : (pkey_retriever:<c,c_pkey> noida)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
luckhnow :- NP : (pkey_retriever:<c,c_pkey> luckhnow)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
kota :- NP : (pkey_retriever:<c,c_pkey> kota)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
jaipur :- NP : (pkey_retriever:<c,c_pkey> jaipur)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
jodhpur :- NP : (pkey_retriever:<c,c_pkey> jodhpur)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
bhopal :- NP : (pkey_retriever:<c,c_pkey> bhopal)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
khandwa :- NP : (pkey_retriever:<c,c_pkey> khandwa)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
katni :- NP : (pkey_retriever:<c,c_pkey> katni)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
reewa :- NP : (pkey_retriever:<c,c_pkey> reewa)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
dehradun :- NP : (pkey_retriever:<c,c_pkey> dehradun)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
rishikesh :- NP : (pkey_retriever:<c,c_pkey> rishikesh)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
nainital :- NP : (pkey_retriever:<c,c_pkey> nainital)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
mussoorie :- NP : (pkey_retriever:<c,c_pkey> mussoorie)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
patna :- NP : (pkey_retriever:<c,c_pkey> patna)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
darbhanga :- NP : (pkey_retriever:<c,c_pkey> darbhanga)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)
the aurangabad :- NP : (pkey_retriever:<c,c_pkey> aurangabad)

// quantifier
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 size:<lo,i>))
largest :- NP/N/PP : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) size:<lo,i>))))
smallest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> $0 size:<lo,i>))
smallest :- NP/N/PP : (lambda $0:<e,i> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) size:<lo,i>))))
//longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 len:<r,i>))
//shortest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> $0 len:<r,i>))
highest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 elevation:<lo,i>))
lowest :- NP/N : (lambda $0:<e,t> (argmin:<<e,t>,<<e,i>,e>> $0 elevation:<lo,i>))
is :- (NP\N)/(NP/N)  : (lambda $0:<<e,t>,e> $0)
are  :- (NP\N)/(NP/N)  : (lambda $0:<<e,t>,e> $0)
with  :- (NP\N)/(NP/N)  : (lambda $0:<<e,t>,e> $0)

// what is the most populated state
most :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
highest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
biggest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
largest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
largest :- (NP/N)/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) $0))))
lowest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> $1 $0)))
sparsest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> $1 $0)))
smallest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> $1 $0)))
smallest :- (NP/N)/PP/N : (lambda $0:<e,e> (lambda $1:<e,t> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> (lambda $3:e (and:<t*,t> ($1 $3) ($2 $3))) $0))))
least :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmin:<<e,t>,<<e,i>,e>> $1 $0)))
// largest city by population
largest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
by :- N/N : (lambda $0:<e,e> $0)

// area of all of the states combined
combined :- (NP\N)\N : (lambda $0:<e,t> (lambda $1:<e,e> (sum:<<e,t>,<<e,i>,i>> $0 $1)))
// total population of ...
total :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (sum:<<e,t>,<<e,i>,i>> $1 $0)))

// what river traverses the most states
the most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
most :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
fewest :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
the least :- NP\N\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))

the most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
most :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmax:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
fewest :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))
the least :- NP\N\(PP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:<e,t> (argmin:<<e,t>,<<e,i>,e>> $2 (lambda $3:e (count:<<e,t>,i> (lambda $4:e (and:<t*,t> ($0 $4) ($1 $4 $3)))))))))

// higher than, etc.
higher than :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
//lower than :- PP\N/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (elevation:<lo,i> $1) (elevation:<lo,i> $0))))
at least one :- (S\NP)\(S\NP/NP)/N : (lambda $0:<e,t> (lambda $1:<e,<e,t>> (lambda $2:e (>:<i,<i,t>> (count:<<e,t>,i> (lambda $3:e (and:<t*,t> ($0 $3) ($1 $3 $2)))) 0:i))))

