has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<a,<c,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (city:<a,c> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<a,<c,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (city:<a,c> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (area:<a,<i,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (area:<a,i> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (area:<a,<i,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (area:<a,i> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<d,<f,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (river:<d,f> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<d,<f,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (river:<d,f> $0))
has :- (S\NP)/NP : (lambda $0:e (lambda $1:e (length:<d,<i,t>> $0 $1)))
has :- NP/NP : (lambda $0:e (length:<d,i> $0))
have :- (S\NP)/NP : (lambda $0:e (lambda $1:e (length:<d,<i,t>> $0 $1)))
have :- NP/NP : (lambda $0:e (length:<d,i> $0))
state_prime :- NP/NP : (lambda $0:e (state_prime:<a,a> $0))
state_prime :- S/PP : (lambda $0:e (state_prime:<a,a> $0))
state_prime :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state_prime:<a,<a,t>> $1 $0)))
state_prime :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state_prime:<a,<t,a>> $1 ($0 $1))))
state_prime :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state_prime:<a,<t,a>> $1 ($0 $1))))
state_prime :- N : state_prime:<a,t>
state :- NP/NP : (lambda $0:e (state:<a,b> $0))
state :- S/PP : (lambda $0:e (state:<a,b> $0))
state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<a,<b,t>> $1 $0)))
state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<a,<t,b>> $1 ($0 $1))))
state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<a,<t,b>> $1 ($0 $1))))
state :- N : state:<a,t>
city :- NP/NP : (lambda $0:e (city:<a,c> $0))
city :- S/PP : (lambda $0:e (city:<a,c> $0))
city :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<a,<c,t>> $1 $0)))
city :- NP/PP : (lambda $0:<e,t> (lambda $1:e (city:<a,<t,c>> $1 ($0 $1))))
city :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (city:<a,<t,c>> $1 ($0 $1))))
city :- N : city:<a,t>
area :- NP/NP : (lambda $0:e (area:<a,i> $0))
area :- S/PP : (lambda $0:e (area:<a,i> $0))
area :- (S\NP)/NP : (lambda $0:e (lambda $1:e (area:<a,<i,t>> $1 $0)))
area :- NP/PP : (lambda $0:<e,t> (lambda $1:e (area:<a,<t,i>> $1 ($0 $1))))
area :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (area:<a,<t,i>> $1 ($0 $1))))
river_prime :- NP/NP : (lambda $0:e (river_prime:<d,d> $0))
river_prime :- S/PP : (lambda $0:e (river_prime:<d,d> $0))
river_prime :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river_prime:<d,<d,t>> $1 $0)))
river_prime :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river_prime:<d,<t,d>> $1 ($0 $1))))
river_prime :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river_prime:<d,<t,d>> $1 ($0 $1))))
river_prime :- N : river_prime:<d,t>
river :- NP/NP : (lambda $0:e (river:<d,f> $0))
river :- S/PP : (lambda $0:e (river:<d,f> $0))
river :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<d,<f,t>> $1 $0)))
river :- NP/PP : (lambda $0:<e,t> (lambda $1:e (river:<d,<t,f>> $1 ($0 $1))))
river :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (river:<d,<t,f>> $1 ($0 $1))))
river :- N : river:<d,t>
state :- NP/NP : (lambda $0:e (state:<d,b> $0))
state :- S/PP : (lambda $0:e (state:<d,b> $0))
state :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<d,<b,t>> $1 $0)))
state :- NP/PP : (lambda $0:<e,t> (lambda $1:e (state:<d,<t,b>> $1 ($0 $1))))
state :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (state:<d,<t,b>> $1 ($0 $1))))
state :- N : state:<d,t>
length :- NP/NP : (lambda $0:e (length:<d,i> $0))
length :- S/PP : (lambda $0:e (length:<d,i> $0))
length :- (S\NP)/NP : (lambda $0:e (lambda $1:e (length:<d,<i,t>> $1 $0)))
length :- NP/PP : (lambda $0:<e,t> (lambda $1:e (length:<d,<t,i>> $1 ($0 $1))))
length :- NP/(S\NP) : (lambda $0:<e,t> (lambda $1:e (length:<d,<t,i>> $1 ($0 $1))))
states :- NP/NP : (lambda $0:e (state:<a,b> $0))
states :- S/PP : (lambda $0:e (state:<a,b> $0))
states :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<a,<b,t>> $1 $0)))
cities :- NP/NP : (lambda $0:e (city:<a,c> $0))
cities :- S/PP : (lambda $0:e (city:<a,c> $0))
cities :- (S\NP)/NP : (lambda $0:e (lambda $1:e (city:<a,<c,t>> $1 $0)))
rivers :- NP/NP : (lambda $0:e (river:<d,f> $0))
rivers :- S/PP : (lambda $0:e (river:<d,f> $0))
rivers :- (S\NP)/NP : (lambda $0:e (lambda $1:e (river:<d,<f,t>> $1 $0)))
states :- NP/NP : (lambda $0:e (state:<d,b> $0))
states :- S/PP : (lambda $0:e (state:<d,b> $0))
states :- (S\NP)/NP : (lambda $0:e (lambda $1:e (state:<d,<b,t>> $1 $0)))
large :- NP/NP : (lambda $0:e (area:<a,i> $0))
larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<a,i> $1) (area:<a,i> $0))))
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 area:<a,i>))
larger :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (area:<a,i> $1) (area:<a,i> $0))))
larger :- (PP/NP)/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
largest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 area:<a,i>))
largest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
largest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
long :- NP/NP : (lambda $0:e (length:<d,i> $0))
longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<d,i> $1) (length:<d,i> $0))))
longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 length:<d,i>))
longer :- PP/NP : (lambda $0:e (lambda $1:e (>:<i,<i,t>> (length:<d,i> $1) (length:<d,i> $0))))
longer :- (PP/NP)/NP : (lambda $0:e (lambda $1:<e,i> (lambda $2:e (>:<i,<i,t>> ($1 $2) ($1 $0)))))
longest :- NP/N : (lambda $0:<e,t> (argmax:<<e,t>,<<e,i>,e>> $0 length:<d,i>))
longest :- (NP/N)/N : (lambda $0:<e,e> (lambda $1:<e,t> (argmax:<<e,t>,<<e,i>,e>> $1 $0)))
longest :- (NP/N)/N : (lambda $0:<e,t> (lambda $1:<e,e> (argmax:<<e,t>,<<e,i>,e>> $0 $1)))
in :- PP/NP : (lambda $0:e (pkey_retriever:<b,a> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<b,a> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:a (lambda $2:e (set_retriever:<a,<b,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<b,a> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<b,a> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:a (lambda $2:e (set_retriever:<a,<b,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<b,a> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<b,a> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:a (lambda $2:e (set_retriever:<a,<b,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<f,d> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<f,d> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:d (lambda $2:e (set_retriever:<d,<f,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<f,d> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<f,d> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:d (lambda $2:e (set_retriever:<d,<f,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<f,d> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<f,d> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:d (lambda $2:e (set_retriever:<d,<f,t>> $1 ($0 $2)))))
in :- PP/NP : (lambda $0:e (pkey_retriever:<b,d> $0))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<b,d> ($0 $1))))
in :- PP/NP : (lambda $0:<e,e> (lambda $1:d (lambda $2:e (set_retriever:<d,<b,t>> $1 ($0 $2)))))
of :- PP/NP : (lambda $0:e (pkey_retriever:<b,d> $0))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<b,d> ($0 $1))))
of :- PP/NP : (lambda $0:<e,e> (lambda $1:d (lambda $2:e (set_retriever:<d,<b,t>> $1 ($0 $2)))))
is :- PP/NP : (lambda $0:e (pkey_retriever:<b,d> $0))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:e (pkey_retriever:<b,d> ($0 $1))))
is :- PP/NP : (lambda $0:<e,e> (lambda $1:d (lambda $2:e (set_retriever:<d,<b,t>> $1 ($0 $2)))))
which :- S/NP : (lambda $0:e $0)
name :- S/NP : (lambda $0:e $0)
the :- NP/NP : (lambda $0:e $0)
what :- S/NP : (lambda $0:e $0)
is :- NP/NP : (lambda $0:e $0)
how :- S/NP : (lambda $0:e $0)
